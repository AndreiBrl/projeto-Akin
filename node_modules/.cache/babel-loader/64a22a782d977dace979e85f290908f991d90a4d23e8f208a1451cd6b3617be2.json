{"ast":null,"code":"import _classCallCheck from \"C:/Users/barbu/Desktop/projeto-Akin/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/barbu/Desktop/projeto-Akin/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { qs, sprint, locationOf, defer } from \"./utils/core\";\nimport Queue from \"./utils/queue\";\nimport EpubCFI from \"./epubcfi\";\nimport { EVENTS } from \"./utils/constants\";\nimport EventEmitter from \"event-emitter\";\n\n/**\n * Find Locations for a Book\n * @param {Spine} spine\n * @param {request} request\n * @param {number} [pause=100]\n */\nvar Locations = /*#__PURE__*/function () {\n  function Locations(spine, request, pause) {\n    _classCallCheck(this, Locations);\n    this.spine = spine;\n    this.request = request;\n    this.pause = pause || 100;\n    this.q = new Queue(this);\n    this.epubcfi = new EpubCFI();\n    this._locations = [];\n    this._locationsWords = [];\n    this.total = 0;\n    this.break = 150;\n    this._current = 0;\n    this._wordCounter = 0;\n    this.currentLocation = '';\n    this._currentCfi = '';\n    this.processingTimeout = undefined;\n  }\n\n  /**\n   * Load all of sections in the book to generate locations\n   * @param  {int} chars how many chars to split on\n   * @return {Promise<Array<string>>} locations\n   */\n  _createClass(Locations, [{\n    key: \"generate\",\n    value: function generate(chars) {\n      if (chars) {\n        this.break = chars;\n      }\n      this.q.pause();\n      this.spine.each(function (section) {\n        if (section.linear) {\n          this.q.enqueue(this.process.bind(this), section);\n        }\n      }.bind(this));\n      return this.q.run().then(function () {\n        this.total = this._locations.length - 1;\n        if (this._currentCfi) {\n          this.currentLocation = this._currentCfi;\n        }\n        return this._locations;\n        // console.log(this.percentage(this.book.rendition.location.start), this.percentage(this.book.rendition.location.end));\n      }.bind(this));\n    }\n  }, {\n    key: \"createRange\",\n    value: function createRange() {\n      return {\n        startContainer: undefined,\n        startOffset: undefined,\n        endContainer: undefined,\n        endOffset: undefined\n      };\n    }\n  }, {\n    key: \"process\",\n    value: function process(section) {\n      return section.load(this.request).then(function (contents) {\n        var completed = new defer();\n        var locations = this.parse(contents, section.cfiBase);\n        this._locations = this._locations.concat(locations);\n        section.unload();\n        this.processingTimeout = setTimeout(function () {\n          return completed.resolve(locations);\n        }, this.pause);\n        return completed.promise;\n      }.bind(this));\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(contents, cfiBase, chars) {\n      var locations = [];\n      var range;\n      var doc = contents.ownerDocument;\n      var body = qs(doc, \"body\");\n      var counter = 0;\n      var prev;\n      var _break = chars || this.break;\n      var parser = function parser(node) {\n        var len = node.length;\n        var dist;\n        var pos = 0;\n        if (node.textContent.trim().length === 0) {\n          return false; // continue\n        }\n\n        // Start range\n        if (counter == 0) {\n          range = this.createRange();\n          range.startContainer = node;\n          range.startOffset = 0;\n        }\n        dist = _break - counter;\n\n        // Node is smaller than a break,\n        // skip over it\n        if (dist > len) {\n          counter += len;\n          pos = len;\n        }\n        while (pos < len) {\n          dist = _break - counter;\n          if (counter === 0) {\n            // Start new range\n            pos += 1;\n            range = this.createRange();\n            range.startContainer = node;\n            range.startOffset = pos;\n          }\n\n          // pos += dist;\n\n          // Gone over\n          if (pos + dist >= len) {\n            // Continue counter for next node\n            counter += len - pos;\n            // break\n            pos = len;\n            // At End\n          } else {\n            // Advance pos\n            pos += dist;\n\n            // End the previous range\n            range.endContainer = node;\n            range.endOffset = pos;\n            // cfi = section.cfiFromRange(range);\n            var cfi = new EpubCFI(range, cfiBase).toString();\n            locations.push(cfi);\n            counter = 0;\n          }\n        }\n        prev = node;\n      };\n      sprint(body, parser.bind(this));\n\n      // Close remaining\n      if (range && range.startContainer && prev) {\n        range.endContainer = prev;\n        range.endOffset = prev.length;\n        var cfi = new EpubCFI(range, cfiBase).toString();\n        locations.push(cfi);\n        counter = 0;\n      }\n      return locations;\n    }\n\n    /**\n     * Load all of sections in the book to generate locations\n     * @param  {string} startCfi start position\n     * @param  {int} wordCount how many words to split on\n     * @param  {int} count result count\n     * @return {object} locations\n     */\n  }, {\n    key: \"generateFromWords\",\n    value: function generateFromWords(startCfi, wordCount, count) {\n      var start = startCfi ? new EpubCFI(startCfi) : undefined;\n      this.q.pause();\n      this._locationsWords = [];\n      this._wordCounter = 0;\n      this.spine.each(function (section) {\n        if (section.linear) {\n          if (start) {\n            if (section.index >= start.spinePos) {\n              this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n            }\n          } else {\n            this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n          }\n        }\n      }.bind(this));\n      return this.q.run().then(function () {\n        if (this._currentCfi) {\n          this.currentLocation = this._currentCfi;\n        }\n        return this._locationsWords;\n      }.bind(this));\n    }\n  }, {\n    key: \"processWords\",\n    value: function processWords(section, wordCount, startCfi, count) {\n      if (count && this._locationsWords.length >= count) {\n        return Promise.resolve();\n      }\n      return section.load(this.request).then(function (contents) {\n        var completed = new defer();\n        var locations = this.parseWords(contents, section, wordCount, startCfi);\n        var remainingCount = count - this._locationsWords.length;\n        this._locationsWords = this._locationsWords.concat(locations.length >= count ? locations.slice(0, remainingCount) : locations);\n        section.unload();\n        this.processingTimeout = setTimeout(function () {\n          return completed.resolve(locations);\n        }, this.pause);\n        return completed.promise;\n      }.bind(this));\n    }\n\n    //http://stackoverflow.com/questions/18679576/counting-words-in-string\n  }, {\n    key: \"countWords\",\n    value: function countWords(s) {\n      s = s.replace(/(^\\s*)|(\\s*$)/gi, \"\"); //exclude  start and end white-space\n      s = s.replace(/[ ]{2,}/gi, \" \"); //2 or more space to 1\n      s = s.replace(/\\n /, \"\\n\"); // exclude newline with a start spacing\n      return s.split(\" \").length;\n    }\n  }, {\n    key: \"parseWords\",\n    value: function parseWords(contents, section, wordCount, startCfi) {\n      var cfiBase = section.cfiBase;\n      var locations = [];\n      var doc = contents.ownerDocument;\n      var body = qs(doc, \"body\");\n      var prev;\n      var _break = wordCount;\n      var foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;\n      var startNode;\n      if (startCfi && section.index === startCfi.spinePos) {\n        startNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);\n      }\n      var parser = function parser(node) {\n        if (!foundStartNode) {\n          if (node === startNode) {\n            foundStartNode = true;\n          } else {\n            return false;\n          }\n        }\n        if (node.textContent.length < 10) {\n          if (node.textContent.trim().length === 0) {\n            return false;\n          }\n        }\n        var len = this.countWords(node.textContent);\n        var dist;\n        var pos = 0;\n        if (len === 0) {\n          return false; // continue\n        }\n\n        dist = _break - this._wordCounter;\n\n        // Node is smaller than a break,\n        // skip over it\n        if (dist > len) {\n          this._wordCounter += len;\n          pos = len;\n        }\n        while (pos < len) {\n          dist = _break - this._wordCounter;\n\n          // Gone over\n          if (pos + dist >= len) {\n            // Continue counter for next node\n            this._wordCounter += len - pos;\n            // break\n            pos = len;\n            // At End\n          } else {\n            // Advance pos\n            pos += dist;\n            var cfi = new EpubCFI(node, cfiBase);\n            locations.push({\n              cfi: cfi.toString(),\n              wordCount: this._wordCounter\n            });\n            this._wordCounter = 0;\n          }\n        }\n        prev = node;\n      };\n      sprint(body, parser.bind(this));\n      return locations;\n    }\n\n    /**\n     * Get a location from an EpubCFI\n     * @param {EpubCFI} cfi\n     * @return {number}\n     */\n  }, {\n    key: \"locationFromCfi\",\n    value: function locationFromCfi(cfi) {\n      var loc;\n      if (EpubCFI.prototype.isCfiString(cfi)) {\n        cfi = new EpubCFI(cfi);\n      }\n      // Check if the location has not been set yet\n      if (this._locations.length === 0) {\n        return -1;\n      }\n      loc = locationOf(cfi, this._locations, this.epubcfi.compare);\n      if (loc > this.total) {\n        return this.total;\n      }\n      return loc;\n    }\n\n    /**\n     * Get a percentage position in locations from an EpubCFI\n     * @param {EpubCFI} cfi\n     * @return {number}\n     */\n  }, {\n    key: \"percentageFromCfi\",\n    value: function percentageFromCfi(cfi) {\n      if (this._locations.length === 0) {\n        return null;\n      }\n      // Find closest cfi\n      var loc = this.locationFromCfi(cfi);\n      // Get percentage in total\n      return this.percentageFromLocation(loc);\n    }\n\n    /**\n     * Get a percentage position from a location index\n     * @param {number} location\n     * @return {number}\n     */\n  }, {\n    key: \"percentageFromLocation\",\n    value: function percentageFromLocation(loc) {\n      if (!loc || !this.total) {\n        return 0;\n      }\n      return loc / this.total;\n    }\n\n    /**\n     * Get an EpubCFI from location index\n     * @param {number} loc\n     * @return {EpubCFI} cfi\n     */\n  }, {\n    key: \"cfiFromLocation\",\n    value: function cfiFromLocation(loc) {\n      var cfi = -1;\n      // check that pg is an int\n      if (typeof loc != \"number\") {\n        loc = parseInt(loc);\n      }\n      if (loc >= 0 && loc < this._locations.length) {\n        cfi = this._locations[loc];\n      }\n      return cfi;\n    }\n\n    /**\n     * Get an EpubCFI from location percentage\n     * @param {number} percentage\n     * @return {EpubCFI} cfi\n     */\n  }, {\n    key: \"cfiFromPercentage\",\n    value: function cfiFromPercentage(percentage) {\n      var loc;\n      if (percentage > 1) {\n        console.warn(\"Normalize cfiFromPercentage value to between 0 - 1\");\n      }\n\n      // Make sure 1 goes to very end\n      if (percentage >= 1) {\n        var cfi = new EpubCFI(this._locations[this.total]);\n        cfi.collapse();\n        return cfi.toString();\n      }\n      loc = Math.ceil(this.total * percentage);\n      return this.cfiFromLocation(loc);\n    }\n\n    /**\n     * Load locations from JSON\n     * @param {json} locations\n     */\n  }, {\n    key: \"load\",\n    value: function load(locations) {\n      if (typeof locations === \"string\") {\n        this._locations = JSON.parse(locations);\n      } else {\n        this._locations = locations;\n      }\n      this.total = this._locations.length - 1;\n      return this._locations;\n    }\n\n    /**\n     * Save locations to JSON\n     * @return {json}\n     */\n  }, {\n    key: \"save\",\n    value: function save() {\n      return JSON.stringify(this._locations);\n    }\n  }, {\n    key: \"getCurrent\",\n    value: function getCurrent() {\n      return this._current;\n    }\n  }, {\n    key: \"setCurrent\",\n    value: function setCurrent(curr) {\n      var loc;\n      if (typeof curr == \"string\") {\n        this._currentCfi = curr;\n      } else if (typeof curr == \"number\") {\n        this._current = curr;\n      } else {\n        return;\n      }\n      if (this._locations.length === 0) {\n        return;\n      }\n      if (typeof curr == \"string\") {\n        loc = this.locationFromCfi(curr);\n        this._current = loc;\n      } else {\n        loc = curr;\n      }\n      this.emit(EVENTS.LOCATIONS.CHANGED, {\n        percentage: this.percentageFromLocation(loc)\n      });\n    }\n\n    /**\n     * Get the current location\n     */\n  }, {\n    key: \"currentLocation\",\n    get: function get() {\n      return this._current;\n    }\n\n    /**\n     * Set the current location\n     */,\n    set: function set(curr) {\n      this.setCurrent(curr);\n    }\n\n    /**\n     * Locations length\n     */\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this._locations.length;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.spine = undefined;\n      this.request = undefined;\n      this.pause = undefined;\n      this.q.stop();\n      this.q = undefined;\n      this.epubcfi = undefined;\n      this._locations = undefined;\n      this.total = undefined;\n      this.break = undefined;\n      this._current = undefined;\n      this.currentLocation = undefined;\n      this._currentCfi = undefined;\n      clearTimeout(this.processingTimeout);\n    }\n  }]);\n  return Locations;\n}();\nEventEmitter(Locations.prototype);\nexport default Locations;","map":{"version":3,"names":["qs","sprint","locationOf","defer","Queue","EpubCFI","EVENTS","EventEmitter","Locations","spine","request","pause","_classCallCheck","q","epubcfi","_locations","_locationsWords","total","break","_current","_wordCounter","currentLocation","_currentCfi","processingTimeout","undefined","_createClass","key","value","generate","chars","each","section","linear","enqueue","process","bind","run","then","length","createRange","startContainer","startOffset","endContainer","endOffset","load","contents","completed","locations","parse","cfiBase","concat","unload","setTimeout","resolve","promise","range","doc","ownerDocument","body","counter","prev","_break","parser","node","len","dist","pos","textContent","trim","cfi","toString","push","generateFromWords","startCfi","wordCount","count","start","index","spinePos","processWords","Promise","parseWords","remainingCount","slice","countWords","s","replace","split","foundStartNode","startNode","findNode","path","steps","locationFromCfi","loc","prototype","isCfiString","compare","percentageFromCfi","percentageFromLocation","cfiFromLocation","parseInt","cfiFromPercentage","percentage","console","warn","collapse","Math","ceil","JSON","save","stringify","getCurrent","setCurrent","curr","emit","LOCATIONS","CHANGED","get","set","destroy","stop","clearTimeout"],"sources":["C:/Users/barbu/Desktop/projeto-Akin/node_modules/epubjs/src/locations.js"],"sourcesContent":["import {qs, sprint, locationOf, defer} from \"./utils/core\";\nimport Queue from \"./utils/queue\";\nimport EpubCFI from \"./epubcfi\";\nimport { EVENTS } from \"./utils/constants\";\nimport EventEmitter from \"event-emitter\";\n\n/**\n * Find Locations for a Book\n * @param {Spine} spine\n * @param {request} request\n * @param {number} [pause=100]\n */\nclass Locations {\n\tconstructor(spine, request, pause) {\n\t\tthis.spine = spine;\n\t\tthis.request = request;\n\t\tthis.pause = pause || 100;\n\n\t\tthis.q = new Queue(this);\n\t\tthis.epubcfi = new EpubCFI();\n\n\t\tthis._locations = [];\n\t\tthis._locationsWords = [];\n\t\tthis.total = 0;\n\n\t\tthis.break = 150;\n\n\t\tthis._current = 0;\n\n\t\tthis._wordCounter = 0;\n\n\t\tthis.currentLocation = '';\n\t\tthis._currentCfi ='';\n\t\tthis.processingTimeout = undefined;\n\t}\n\n\t/**\n\t * Load all of sections in the book to generate locations\n\t * @param  {int} chars how many chars to split on\n\t * @return {Promise<Array<string>>} locations\n\t */\n\tgenerate(chars) {\n\n\t\tif (chars) {\n\t\t\tthis.break = chars;\n\t\t}\n\n\t\tthis.q.pause();\n\n\t\tthis.spine.each(function(section) {\n\t\t\tif (section.linear) {\n\t\t\t\tthis.q.enqueue(this.process.bind(this), section);\n\t\t\t}\n\t\t}.bind(this));\n\n\t\treturn this.q.run().then(function() {\n\t\t\tthis.total = this._locations.length - 1;\n\n\t\t\tif (this._currentCfi) {\n\t\t\t\tthis.currentLocation = this._currentCfi;\n\t\t\t}\n\n\t\t\treturn this._locations;\n\t\t\t// console.log(this.percentage(this.book.rendition.location.start), this.percentage(this.book.rendition.location.end));\n\t\t}.bind(this));\n\n\t}\n\n\tcreateRange () {\n\t\treturn {\n\t\t\tstartContainer: undefined,\n\t\t\tstartOffset: undefined,\n\t\t\tendContainer: undefined,\n\t\t\tendOffset: undefined\n\t\t};\n\t}\n\n\tprocess(section) {\n\n\t\treturn section.load(this.request)\n\t\t\t.then(function(contents) {\n\t\t\t\tvar completed = new defer();\n\t\t\t\tvar locations = this.parse(contents, section.cfiBase);\n\t\t\t\tthis._locations = this._locations.concat(locations);\n\n\t\t\t\tsection.unload();\n\n\t\t\t\tthis.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n\t\t\t\treturn completed.promise;\n\t\t\t}.bind(this));\n\n\t}\n\n\tparse(contents, cfiBase, chars) {\n\t\tvar locations = [];\n\t\tvar range;\n\t\tvar doc = contents.ownerDocument;\n\t\tvar body = qs(doc, \"body\");\n\t\tvar counter = 0;\n\t\tvar prev;\n\t\tvar _break = chars || this.break;\n\t\tvar parser = function(node) {\n\t\t\tvar len = node.length;\n\t\t\tvar dist;\n\t\t\tvar pos = 0;\n\n\t\t\tif (node.textContent.trim().length === 0) {\n\t\t\t\treturn false; // continue\n\t\t\t}\n\n\t\t\t// Start range\n\t\t\tif (counter == 0) {\n\t\t\t\trange = this.createRange();\n\t\t\t\trange.startContainer = node;\n\t\t\t\trange.startOffset = 0;\n\t\t\t}\n\n\t\t\tdist = _break - counter;\n\n\t\t\t// Node is smaller than a break,\n\t\t\t// skip over it\n\t\t\tif(dist > len){\n\t\t\t\tcounter += len;\n\t\t\t\tpos = len;\n\t\t\t}\n\n\n\t\t\twhile (pos < len) {\n\t\t\t\tdist = _break - counter;\n\n\t\t\t\tif (counter === 0) {\n\t\t\t\t\t// Start new range\n\t\t\t\t\tpos += 1;\n\t\t\t\t\trange = this.createRange();\n\t\t\t\t\trange.startContainer = node;\n\t\t\t\t\trange.startOffset = pos;\n\t\t\t\t}\n\n\t\t\t\t// pos += dist;\n\n\t\t\t\t// Gone over\n\t\t\t\tif(pos + dist >= len){\n\t\t\t\t\t// Continue counter for next node\n\t\t\t\t\tcounter += len - pos;\n\t\t\t\t\t// break\n\t\t\t\t\tpos = len;\n\t\t\t\t// At End\n\t\t\t\t} else {\n\t\t\t\t\t// Advance pos\n\t\t\t\t\tpos += dist;\n\n\t\t\t\t\t// End the previous range\n\t\t\t\t\trange.endContainer = node;\n\t\t\t\t\trange.endOffset = pos;\n\t\t\t\t\t// cfi = section.cfiFromRange(range);\n\t\t\t\t\tlet cfi = new EpubCFI(range, cfiBase).toString();\n\t\t\t\t\tlocations.push(cfi);\n\t\t\t\t\tcounter = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = node;\n\t\t};\n\n\t\tsprint(body, parser.bind(this));\n\n\t\t// Close remaining\n\t\tif (range && range.startContainer && prev) {\n\t\t\trange.endContainer = prev;\n\t\t\trange.endOffset = prev.length;\n\t\t\tlet cfi = new EpubCFI(range, cfiBase).toString();\n\t\t\tlocations.push(cfi);\n\t\t\tcounter = 0;\n\t\t}\n\n\t\treturn locations;\n\t}\n\n\n\t/**\n\t * Load all of sections in the book to generate locations\n\t * @param  {string} startCfi start position\n\t * @param  {int} wordCount how many words to split on\n\t * @param  {int} count result count\n\t * @return {object} locations\n\t */\n\tgenerateFromWords(startCfi, wordCount, count) {\n\t\tvar start = startCfi ? new EpubCFI(startCfi) : undefined;\n\t\tthis.q.pause();\n\t\tthis._locationsWords = [];\n\t\tthis._wordCounter = 0;\n\n\t\tthis.spine.each(function(section) {\n\t\t\tif (section.linear) {\n\t\t\t\tif (start) {\n\t\t\t\t\tif (section.index >= start.spinePos) {\n\t\t\t\t\t\tthis.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this));\n\n\t\treturn this.q.run().then(function() {\n\t\t\tif (this._currentCfi) {\n\t\t\t\tthis.currentLocation = this._currentCfi;\n\t\t\t}\n\n\t\t\treturn this._locationsWords;\n\t\t}.bind(this));\n\n\t}\n\n\tprocessWords(section, wordCount, startCfi, count) {\n\t\tif (count && this._locationsWords.length >= count) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn section.load(this.request)\n\t\t\t.then(function(contents) {\n\t\t\t\tvar completed = new defer();\n\t\t\t\tvar locations = this.parseWords(contents, section, wordCount, startCfi);\n\t\t\t\tvar remainingCount = count - this._locationsWords.length;\n\t\t\t\tthis._locationsWords = this._locationsWords.concat(locations.length >= count ? locations.slice(0, remainingCount) : locations);\n\n\t\t\t\tsection.unload();\n\n\t\t\t\tthis.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);\n\t\t\t\treturn completed.promise;\n\t\t\t}.bind(this));\n\t}\n\n\t//http://stackoverflow.com/questions/18679576/counting-words-in-string\n\tcountWords(s) {\n\t\ts = s.replace(/(^\\s*)|(\\s*$)/gi, \"\");//exclude  start and end white-space\n\t\ts = s.replace(/[ ]{2,}/gi, \" \");//2 or more space to 1\n\t\ts = s.replace(/\\n /, \"\\n\"); // exclude newline with a start spacing\n\t\treturn s.split(\" \").length;\n\t}\n\n\tparseWords(contents, section, wordCount, startCfi) {\n\t\tvar cfiBase = section.cfiBase;\n\t\tvar locations = [];\n\t\tvar doc = contents.ownerDocument;\n\t\tvar body = qs(doc, \"body\");\n\t\tvar prev;\n\t\tvar _break = wordCount;\n\t\tvar foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;\n\t\tvar startNode;\n\t\tif (startCfi && section.index === startCfi.spinePos) {\n\t\t\tstartNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);\n\t\t}\n\t\tvar parser = function(node) {\n\t\t\tif (!foundStartNode) {\n\t\t\t\tif (node === startNode) {\n\t\t\t\t\tfoundStartNode = true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.textContent.length < 10) {\n\t\t\t\tif (node.textContent.trim().length === 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar len  = this.countWords(node.textContent);\n\t\t\tvar dist;\n\t\t\tvar pos = 0;\n\n\t\t\tif (len === 0) {\n\t\t\t\treturn false; // continue\n\t\t\t}\n\n\t\t\tdist = _break - this._wordCounter;\n\n\t\t\t// Node is smaller than a break,\n\t\t\t// skip over it\n\t\t\tif (dist > len) {\n\t\t\t\tthis._wordCounter += len;\n\t\t\t\tpos = len;\n\t\t\t}\n\n\n\t\t\twhile (pos < len) {\n\t\t\t\tdist = _break - this._wordCounter;\n\n\t\t\t\t// Gone over\n\t\t\t\tif (pos + dist >= len) {\n\t\t\t\t\t// Continue counter for next node\n\t\t\t\t\tthis._wordCounter += len - pos;\n\t\t\t\t\t// break\n\t\t\t\t\tpos = len;\n\t\t\t\t\t// At End\n\t\t\t\t} else {\n\t\t\t\t\t// Advance pos\n\t\t\t\t\tpos += dist;\n\n\t\t\t\t\tlet cfi = new EpubCFI(node, cfiBase);\n\t\t\t\t\tlocations.push({ cfi: cfi.toString(), wordCount: this._wordCounter });\n\t\t\t\t\tthis._wordCounter = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = node;\n\t\t};\n\n\t\tsprint(body, parser.bind(this));\n\n\t\treturn locations;\n\t}\n\n\t/**\n\t * Get a location from an EpubCFI\n\t * @param {EpubCFI} cfi\n\t * @return {number}\n\t */\n\tlocationFromCfi(cfi){\n\t\tlet loc;\n\t\tif (EpubCFI.prototype.isCfiString(cfi)) {\n\t\t\tcfi = new EpubCFI(cfi);\n\t\t}\n\t\t// Check if the location has not been set yet\n\t\tif(this._locations.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tloc = locationOf(cfi, this._locations, this.epubcfi.compare);\n\n\t\tif (loc > this.total) {\n\t\t\treturn this.total;\n\t\t}\n\n\t\treturn loc;\n\t}\n\n\t/**\n\t * Get a percentage position in locations from an EpubCFI\n\t * @param {EpubCFI} cfi\n\t * @return {number}\n\t */\n\tpercentageFromCfi(cfi) {\n\t\tif(this._locations.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\t// Find closest cfi\n\t\tvar loc = this.locationFromCfi(cfi);\n\t\t// Get percentage in total\n\t\treturn this.percentageFromLocation(loc);\n\t}\n\n\t/**\n\t * Get a percentage position from a location index\n\t * @param {number} location\n\t * @return {number}\n\t */\n\tpercentageFromLocation(loc) {\n\t\tif (!loc || !this.total) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn (loc / this.total);\n\t}\n\n\t/**\n\t * Get an EpubCFI from location index\n\t * @param {number} loc\n\t * @return {EpubCFI} cfi\n\t */\n\tcfiFromLocation(loc){\n\t\tvar cfi = -1;\n\t\t// check that pg is an int\n\t\tif(typeof loc != \"number\"){\n\t\t\tloc = parseInt(loc);\n\t\t}\n\n\t\tif(loc >= 0 && loc < this._locations.length) {\n\t\t\tcfi = this._locations[loc];\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Get an EpubCFI from location percentage\n\t * @param {number} percentage\n\t * @return {EpubCFI} cfi\n\t */\n\tcfiFromPercentage(percentage){\n\t\tlet loc;\n\t\tif (percentage > 1) {\n\t\t\tconsole.warn(\"Normalize cfiFromPercentage value to between 0 - 1\");\n\t\t}\n\n\t\t// Make sure 1 goes to very end\n\t\tif (percentage >= 1) {\n\t\t\tlet cfi = new EpubCFI(this._locations[this.total]);\n\t\t\tcfi.collapse();\n\t\t\treturn cfi.toString();\n\t\t}\n\n\t\tloc = Math.ceil(this.total * percentage);\n\t\treturn this.cfiFromLocation(loc);\n\t}\n\n\t/**\n\t * Load locations from JSON\n\t * @param {json} locations\n\t */\n\tload(locations){\n\t\tif (typeof locations === \"string\") {\n\t\t\tthis._locations = JSON.parse(locations);\n\t\t} else {\n\t\t\tthis._locations = locations;\n\t\t}\n\t\tthis.total = this._locations.length - 1;\n\t\treturn this._locations;\n\t}\n\n\t/**\n\t * Save locations to JSON\n\t * @return {json}\n\t */\n\tsave(){\n\t\treturn JSON.stringify(this._locations);\n\t}\n\n\tgetCurrent(){\n\t\treturn this._current;\n\t}\n\n\tsetCurrent(curr){\n\t\tvar loc;\n\n\t\tif(typeof curr == \"string\"){\n\t\t\tthis._currentCfi = curr;\n\t\t} else if (typeof curr == \"number\") {\n\t\t\tthis._current = curr;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\tif(this._locations.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(typeof curr == \"string\"){\n\t\t\tloc = this.locationFromCfi(curr);\n\t\t\tthis._current = loc;\n\t\t} else {\n\t\t\tloc = curr;\n\t\t}\n\n\t\tthis.emit(EVENTS.LOCATIONS.CHANGED, {\n\t\t\tpercentage: this.percentageFromLocation(loc)\n\t\t});\n\t}\n\n\t/**\n\t * Get the current location\n\t */\n\tget currentLocation() {\n\t\treturn this._current;\n\t}\n\n\t/**\n\t * Set the current location\n\t */\n\tset currentLocation(curr) {\n\t\tthis.setCurrent(curr);\n\t}\n\n\t/**\n\t * Locations length\n\t */\n\tlength () {\n\t\treturn this._locations.length;\n\t}\n\n\tdestroy () {\n\t\tthis.spine = undefined;\n\t\tthis.request = undefined;\n\t\tthis.pause = undefined;\n\n\t\tthis.q.stop();\n\t\tthis.q = undefined;\n\t\tthis.epubcfi = undefined;\n\n\t\tthis._locations = undefined\n\t\tthis.total = undefined;\n\n\t\tthis.break = undefined;\n\t\tthis._current = undefined;\n\n\t\tthis.currentLocation = undefined;\n\t\tthis._currentCfi = undefined;\n\t\tclearTimeout(this.processingTimeout);\n\t}\n}\n\nEventEmitter(Locations.prototype);\n\nexport default Locations;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}