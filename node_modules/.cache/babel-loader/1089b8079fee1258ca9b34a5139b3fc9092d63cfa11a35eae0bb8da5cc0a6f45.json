{"ast":null,"code":"import _classCallCheck from \"C:/Users/barbu/Desktop/projeto-Akin/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/barbu/Desktop/projeto-Akin/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { extend, type, findChildren, RangeObject, isNumber } from \"./utils/core\";\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar DOCUMENT_NODE = 9;\n\n/**\n\t* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html\n\n\t* Implements:\n\t* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)\n\t* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)\n\n\t* Does Not Implement:\n\t* - Temporal Offset (~)\n\t* - Spatial Offset (@)\n\t* - Temporal-Spatial Offset (~ + @)\n\t* - Text Location Assertion ([)\n\t* @class\n\t@param {string | Range | Node } [cfiFrom]\n\t@param {string | object} [base]\n\t@param {string} [ignoreClass] class to ignore when parsing DOM\n*/\nvar EpubCFI = /*#__PURE__*/function () {\n  function EpubCFI(cfiFrom, base, ignoreClass) {\n    _classCallCheck(this, EpubCFI);\n    var type;\n    this.str = \"\";\n    this.base = {};\n    this.spinePos = 0; // For compatibility\n\n    this.range = false; // true || false;\n\n    this.path = {};\n    this.start = null;\n    this.end = null;\n\n    // Allow instantiation without the \"new\" keyword\n    if (!(this instanceof EpubCFI)) {\n      return new EpubCFI(cfiFrom, base, ignoreClass);\n    }\n    if (typeof base === \"string\") {\n      this.base = this.parseComponent(base);\n    } else if (typeof base === \"object\" && base.steps) {\n      this.base = base;\n    }\n    type = this.checkType(cfiFrom);\n    if (type === \"string\") {\n      this.str = cfiFrom;\n      return extend(this, this.parse(cfiFrom));\n    } else if (type === \"range\") {\n      return extend(this, this.fromRange(cfiFrom, this.base, ignoreClass));\n    } else if (type === \"node\") {\n      return extend(this, this.fromNode(cfiFrom, this.base, ignoreClass));\n    } else if (type === \"EpubCFI\" && cfiFrom.path) {\n      return cfiFrom;\n    } else if (!cfiFrom) {\n      return this;\n    } else {\n      throw new TypeError(\"not a valid argument for EpubCFI\");\n    }\n  }\n\n  /**\n   * Check the type of constructor input\n   * @private\n   */\n  _createClass(EpubCFI, [{\n    key: \"checkType\",\n    value: function checkType(cfi) {\n      if (this.isCfiString(cfi)) {\n        return \"string\";\n        // Is a range object\n      } else if (cfi && typeof cfi === \"object\" && (type(cfi) === \"Range\" || typeof cfi.startContainer != \"undefined\")) {\n        return \"range\";\n      } else if (cfi && typeof cfi === \"object\" && typeof cfi.nodeType != \"undefined\") {\n        // || typeof cfi === \"function\"\n        return \"node\";\n      } else if (cfi && typeof cfi === \"object\" && cfi instanceof EpubCFI) {\n        return \"EpubCFI\";\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Parse a cfi string to a CFI object representation\n     * @param {string} cfiStr\n     * @returns {object} cfi\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(cfiStr) {\n      var cfi = {\n        spinePos: -1,\n        range: false,\n        base: {},\n        path: {},\n        start: null,\n        end: null\n      };\n      var baseComponent, pathComponent, range;\n      if (typeof cfiStr !== \"string\") {\n        return {\n          spinePos: -1\n        };\n      }\n      if (cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length - 1] === \")\") {\n        // Remove initial epubcfi( and ending )\n        cfiStr = cfiStr.slice(8, cfiStr.length - 1);\n      }\n      baseComponent = this.getChapterComponent(cfiStr);\n\n      // Make sure this is a valid cfi or return\n      if (!baseComponent) {\n        return {\n          spinePos: -1\n        };\n      }\n      cfi.base = this.parseComponent(baseComponent);\n      pathComponent = this.getPathComponent(cfiStr);\n      cfi.path = this.parseComponent(pathComponent);\n      range = this.getRange(cfiStr);\n      if (range) {\n        cfi.range = true;\n        cfi.start = this.parseComponent(range[0]);\n        cfi.end = this.parseComponent(range[1]);\n      }\n\n      // Get spine node position\n      // cfi.spineSegment = cfi.base.steps[1];\n\n      // Chapter segment is always the second step\n      cfi.spinePos = cfi.base.steps[1].index;\n      return cfi;\n    }\n  }, {\n    key: \"parseComponent\",\n    value: function parseComponent(componentStr) {\n      var component = {\n        steps: [],\n        terminal: {\n          offset: null,\n          assertion: null\n        }\n      };\n      var parts = componentStr.split(\":\");\n      var steps = parts[0].split(\"/\");\n      var terminal;\n      if (parts.length > 1) {\n        terminal = parts[1];\n        component.terminal = this.parseTerminal(terminal);\n      }\n      if (steps[0] === \"\") {\n        steps.shift(); // Ignore the first slash\n      }\n\n      component.steps = steps.map(function (step) {\n        return this.parseStep(step);\n      }.bind(this));\n      return component;\n    }\n  }, {\n    key: \"parseStep\",\n    value: function parseStep(stepStr) {\n      var type, num, index, has_brackets, id;\n      has_brackets = stepStr.match(/\\[(.*)\\]/);\n      if (has_brackets && has_brackets[1]) {\n        id = has_brackets[1];\n      }\n\n      //-- Check if step is a text node or element\n      num = parseInt(stepStr);\n      if (isNaN(num)) {\n        return;\n      }\n      if (num % 2 === 0) {\n        // Even = is an element\n        type = \"element\";\n        index = num / 2 - 1;\n      } else {\n        type = \"text\";\n        index = (num - 1) / 2;\n      }\n      return {\n        \"type\": type,\n        \"index\": index,\n        \"id\": id || null\n      };\n    }\n  }, {\n    key: \"parseTerminal\",\n    value: function parseTerminal(termialStr) {\n      var characterOffset, textLocationAssertion;\n      var assertion = termialStr.match(/\\[(.*)\\]/);\n      if (assertion && assertion[1]) {\n        characterOffset = parseInt(termialStr.split(\"[\")[0]);\n        textLocationAssertion = assertion[1];\n      } else {\n        characterOffset = parseInt(termialStr);\n      }\n      if (!isNumber(characterOffset)) {\n        characterOffset = null;\n      }\n      return {\n        \"offset\": characterOffset,\n        \"assertion\": textLocationAssertion\n      };\n    }\n  }, {\n    key: \"getChapterComponent\",\n    value: function getChapterComponent(cfiStr) {\n      var indirection = cfiStr.split(\"!\");\n      return indirection[0];\n    }\n  }, {\n    key: \"getPathComponent\",\n    value: function getPathComponent(cfiStr) {\n      var indirection = cfiStr.split(\"!\");\n      if (indirection[1]) {\n        var ranges = indirection[1].split(\",\");\n        return ranges[0];\n      }\n    }\n  }, {\n    key: \"getRange\",\n    value: function getRange(cfiStr) {\n      var ranges = cfiStr.split(\",\");\n      if (ranges.length === 3) {\n        return [ranges[1], ranges[2]];\n      }\n      return false;\n    }\n  }, {\n    key: \"getCharecterOffsetComponent\",\n    value: function getCharecterOffsetComponent(cfiStr) {\n      var splitStr = cfiStr.split(\":\");\n      return splitStr[1] || \"\";\n    }\n  }, {\n    key: \"joinSteps\",\n    value: function joinSteps(steps) {\n      if (!steps) {\n        return \"\";\n      }\n      return steps.map(function (part) {\n        var segment = \"\";\n        if (part.type === \"element\") {\n          segment += (part.index + 1) * 2;\n        }\n        if (part.type === \"text\") {\n          segment += 1 + 2 * part.index; // TODO: double check that this is odd\n        }\n\n        if (part.id) {\n          segment += \"[\" + part.id + \"]\";\n        }\n        return segment;\n      }).join(\"/\");\n    }\n  }, {\n    key: \"segmentString\",\n    value: function segmentString(segment) {\n      var segmentString = \"/\";\n      segmentString += this.joinSteps(segment.steps);\n      if (segment.terminal && segment.terminal.offset != null) {\n        segmentString += \":\" + segment.terminal.offset;\n      }\n      if (segment.terminal && segment.terminal.assertion != null) {\n        segmentString += \"[\" + segment.terminal.assertion + \"]\";\n      }\n      return segmentString;\n    }\n\n    /**\n     * Convert CFI to a epubcfi(...) string\n     * @returns {string} epubcfi\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var cfiString = \"epubcfi(\";\n      cfiString += this.segmentString(this.base);\n      cfiString += \"!\";\n      cfiString += this.segmentString(this.path);\n\n      // Add Range, if present\n      if (this.range && this.start) {\n        cfiString += \",\";\n        cfiString += this.segmentString(this.start);\n      }\n      if (this.range && this.end) {\n        cfiString += \",\";\n        cfiString += this.segmentString(this.end);\n      }\n      cfiString += \")\";\n      return cfiString;\n    }\n\n    /**\n     * Compare which of two CFIs is earlier in the text\n     * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0\n     */\n  }, {\n    key: \"compare\",\n    value: function compare(cfiOne, cfiTwo) {\n      var stepsA, stepsB;\n      var terminalA, terminalB;\n      var rangeAStartSteps, rangeAEndSteps;\n      var rangeBEndSteps, rangeBEndSteps;\n      var rangeAStartTerminal, rangeAEndTerminal;\n      var rangeBStartTerminal, rangeBEndTerminal;\n      if (typeof cfiOne === \"string\") {\n        cfiOne = new EpubCFI(cfiOne);\n      }\n      if (typeof cfiTwo === \"string\") {\n        cfiTwo = new EpubCFI(cfiTwo);\n      }\n      // Compare Spine Positions\n      if (cfiOne.spinePos > cfiTwo.spinePos) {\n        return 1;\n      }\n      if (cfiOne.spinePos < cfiTwo.spinePos) {\n        return -1;\n      }\n      if (cfiOne.range) {\n        stepsA = cfiOne.path.steps.concat(cfiOne.start.steps);\n        terminalA = cfiOne.start.terminal;\n      } else {\n        stepsA = cfiOne.path.steps;\n        terminalA = cfiOne.path.terminal;\n      }\n      if (cfiTwo.range) {\n        stepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);\n        terminalB = cfiTwo.start.terminal;\n      } else {\n        stepsB = cfiTwo.path.steps;\n        terminalB = cfiTwo.path.terminal;\n      }\n\n      // Compare Each Step in the First item\n      for (var i = 0; i < stepsA.length; i++) {\n        if (!stepsA[i]) {\n          return -1;\n        }\n        if (!stepsB[i]) {\n          return 1;\n        }\n        if (stepsA[i].index > stepsB[i].index) {\n          return 1;\n        }\n        if (stepsA[i].index < stepsB[i].index) {\n          return -1;\n        }\n        // Otherwise continue checking\n      }\n\n      // All steps in First equal to Second and First is Less Specific\n      if (stepsA.length < stepsB.length) {\n        return -1;\n      }\n\n      // Compare the character offset of the text node\n      if (terminalA.offset > terminalB.offset) {\n        return 1;\n      }\n      if (terminalA.offset < terminalB.offset) {\n        return -1;\n      }\n\n      // CFI's are equal\n      return 0;\n    }\n  }, {\n    key: \"step\",\n    value: function step(node) {\n      var nodeType = node.nodeType === TEXT_NODE ? \"text\" : \"element\";\n      return {\n        \"id\": node.id,\n        \"tagName\": node.tagName,\n        \"type\": nodeType,\n        \"index\": this.position(node)\n      };\n    }\n  }, {\n    key: \"filteredStep\",\n    value: function filteredStep(node, ignoreClass) {\n      var filteredNode = this.filter(node, ignoreClass);\n      var nodeType;\n\n      // Node filtered, so ignore\n      if (!filteredNode) {\n        return;\n      }\n\n      // Otherwise add the filter node in\n      nodeType = filteredNode.nodeType === TEXT_NODE ? \"text\" : \"element\";\n      return {\n        \"id\": filteredNode.id,\n        \"tagName\": filteredNode.tagName,\n        \"type\": nodeType,\n        \"index\": this.filteredPosition(filteredNode, ignoreClass)\n      };\n    }\n  }, {\n    key: \"pathTo\",\n    value: function pathTo(node, offset, ignoreClass) {\n      var segment = {\n        steps: [],\n        terminal: {\n          offset: null,\n          assertion: null\n        }\n      };\n      var currentNode = node;\n      var step;\n      while (currentNode && currentNode.parentNode && currentNode.parentNode.nodeType != DOCUMENT_NODE) {\n        if (ignoreClass) {\n          step = this.filteredStep(currentNode, ignoreClass);\n        } else {\n          step = this.step(currentNode);\n        }\n        if (step) {\n          segment.steps.unshift(step);\n        }\n        currentNode = currentNode.parentNode;\n      }\n      if (offset != null && offset >= 0) {\n        segment.terminal.offset = offset;\n\n        // Make sure we are getting to a textNode if there is an offset\n        if (segment.steps[segment.steps.length - 1].type != \"text\") {\n          segment.steps.push({\n            \"type\": \"text\",\n            \"index\": 0\n          });\n        }\n      }\n      return segment;\n    }\n  }, {\n    key: \"equalStep\",\n    value: function equalStep(stepA, stepB) {\n      if (!stepA || !stepB) {\n        return false;\n      }\n      if (stepA.index === stepB.index && stepA.id === stepB.id && stepA.type === stepB.type) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Create a CFI object from a Range\n     * @param {Range} range\n     * @param {string | object} base\n     * @param {string} [ignoreClass]\n     * @returns {object} cfi\n     */\n  }, {\n    key: \"fromRange\",\n    value: function fromRange(range, base, ignoreClass) {\n      var cfi = {\n        range: false,\n        base: {},\n        path: {},\n        start: null,\n        end: null\n      };\n      var start = range.startContainer;\n      var end = range.endContainer;\n      var startOffset = range.startOffset;\n      var endOffset = range.endOffset;\n      var needsIgnoring = false;\n      if (ignoreClass) {\n        // Tell pathTo if / what to ignore\n        needsIgnoring = start.ownerDocument.querySelector(\".\" + ignoreClass) != null;\n      }\n      if (typeof base === \"string\") {\n        cfi.base = this.parseComponent(base);\n        cfi.spinePos = cfi.base.steps[1].index;\n      } else if (typeof base === \"object\") {\n        cfi.base = base;\n      }\n      if (range.collapsed) {\n        if (needsIgnoring) {\n          startOffset = this.patchOffset(start, startOffset, ignoreClass);\n        }\n        cfi.path = this.pathTo(start, startOffset, ignoreClass);\n      } else {\n        cfi.range = true;\n        if (needsIgnoring) {\n          startOffset = this.patchOffset(start, startOffset, ignoreClass);\n        }\n        cfi.start = this.pathTo(start, startOffset, ignoreClass);\n        if (needsIgnoring) {\n          endOffset = this.patchOffset(end, endOffset, ignoreClass);\n        }\n        cfi.end = this.pathTo(end, endOffset, ignoreClass);\n\n        // Create a new empty path\n        cfi.path = {\n          steps: [],\n          terminal: null\n        };\n\n        // Push steps that are shared between start and end to the common path\n        var len = cfi.start.steps.length;\n        var i;\n        for (i = 0; i < len; i++) {\n          if (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n            if (i === len - 1) {\n              // Last step is equal, check terminals\n              if (cfi.start.terminal === cfi.end.terminal) {\n                // CFI's are equal\n                cfi.path.steps.push(cfi.start.steps[i]);\n                // Not a range\n                cfi.range = false;\n              }\n            } else {\n              cfi.path.steps.push(cfi.start.steps[i]);\n            }\n          } else {\n            break;\n          }\n        }\n        cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);\n        cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);\n\n        // TODO: Add Sanity check to make sure that the end if greater than the start\n      }\n\n      return cfi;\n    }\n\n    /**\n     * Create a CFI object from a Node\n     * @param {Node} anchor\n     * @param {string | object} base\n     * @param {string} [ignoreClass]\n     * @returns {object} cfi\n     */\n  }, {\n    key: \"fromNode\",\n    value: function fromNode(anchor, base, ignoreClass) {\n      var cfi = {\n        range: false,\n        base: {},\n        path: {},\n        start: null,\n        end: null\n      };\n      if (typeof base === \"string\") {\n        cfi.base = this.parseComponent(base);\n        cfi.spinePos = cfi.base.steps[1].index;\n      } else if (typeof base === \"object\") {\n        cfi.base = base;\n      }\n      cfi.path = this.pathTo(anchor, null, ignoreClass);\n      return cfi;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(anchor, ignoreClass) {\n      var needsIgnoring;\n      var sibling; // to join with\n      var parent, previousSibling, nextSibling;\n      var isText = false;\n      if (anchor.nodeType === TEXT_NODE) {\n        isText = true;\n        parent = anchor.parentNode;\n        needsIgnoring = anchor.parentNode.classList.contains(ignoreClass);\n      } else {\n        isText = false;\n        needsIgnoring = anchor.classList.contains(ignoreClass);\n      }\n      if (needsIgnoring && isText) {\n        previousSibling = parent.previousSibling;\n        nextSibling = parent.nextSibling;\n\n        // If the sibling is a text node, join the nodes\n        if (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n          sibling = previousSibling;\n        } else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {\n          sibling = nextSibling;\n        }\n        if (sibling) {\n          return sibling;\n        } else {\n          // Parent will be ignored on next step\n          return anchor;\n        }\n      } else if (needsIgnoring && !isText) {\n        // Otherwise just skip the element node\n        return false;\n      } else {\n        // No need to filter\n        return anchor;\n      }\n    }\n  }, {\n    key: \"patchOffset\",\n    value: function patchOffset(anchor, offset, ignoreClass) {\n      if (anchor.nodeType != TEXT_NODE) {\n        throw new Error(\"Anchor must be a text node\");\n      }\n      var curr = anchor;\n      var totalOffset = offset;\n\n      // If the parent is a ignored node, get offset from it's start\n      if (anchor.parentNode.classList.contains(ignoreClass)) {\n        curr = anchor.parentNode;\n      }\n      while (curr.previousSibling) {\n        if (curr.previousSibling.nodeType === ELEMENT_NODE) {\n          // Originally a text node, so join\n          if (curr.previousSibling.classList.contains(ignoreClass)) {\n            totalOffset += curr.previousSibling.textContent.length;\n          } else {\n            break; // Normal node, dont join\n          }\n        } else {\n          // If the previous sibling is a text node, join the nodes\n          totalOffset += curr.previousSibling.textContent.length;\n        }\n        curr = curr.previousSibling;\n      }\n      return totalOffset;\n    }\n  }, {\n    key: \"normalizedMap\",\n    value: function normalizedMap(children, nodeType, ignoreClass) {\n      var output = {};\n      var prevIndex = -1;\n      var i,\n        len = children.length;\n      var currNodeType;\n      var prevNodeType;\n      for (i = 0; i < len; i++) {\n        currNodeType = children[i].nodeType;\n\n        // Check if needs ignoring\n        if (currNodeType === ELEMENT_NODE && children[i].classList.contains(ignoreClass)) {\n          currNodeType = TEXT_NODE;\n        }\n        if (i > 0 && currNodeType === TEXT_NODE && prevNodeType === TEXT_NODE) {\n          // join text nodes\n          output[i] = prevIndex;\n        } else if (nodeType === currNodeType) {\n          prevIndex = prevIndex + 1;\n          output[i] = prevIndex;\n        }\n        prevNodeType = currNodeType;\n      }\n      return output;\n    }\n  }, {\n    key: \"position\",\n    value: function position(anchor) {\n      var children, index;\n      if (anchor.nodeType === ELEMENT_NODE) {\n        children = anchor.parentNode.children;\n        if (!children) {\n          children = findChildren(anchor.parentNode);\n        }\n        index = Array.prototype.indexOf.call(children, anchor);\n      } else {\n        children = this.textNodes(anchor.parentNode);\n        index = children.indexOf(anchor);\n      }\n      return index;\n    }\n  }, {\n    key: \"filteredPosition\",\n    value: function filteredPosition(anchor, ignoreClass) {\n      var children, index, map;\n      if (anchor.nodeType === ELEMENT_NODE) {\n        children = anchor.parentNode.children;\n        map = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);\n      } else {\n        children = anchor.parentNode.childNodes;\n        // Inside an ignored node\n        if (anchor.parentNode.classList.contains(ignoreClass)) {\n          anchor = anchor.parentNode;\n          children = anchor.parentNode.childNodes;\n        }\n        map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n      }\n      index = Array.prototype.indexOf.call(children, anchor);\n      return map[index];\n    }\n  }, {\n    key: \"stepsToXpath\",\n    value: function stepsToXpath(steps) {\n      var xpath = [\".\", \"*\"];\n      steps.forEach(function (step) {\n        var position = step.index + 1;\n        if (step.id) {\n          xpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n        } else if (step.type === \"text\") {\n          xpath.push(\"text()[\" + position + \"]\");\n        } else {\n          xpath.push(\"*[\" + position + \"]\");\n        }\n      });\n      return xpath.join(\"/\");\n    }\n\n    /*\n    \tTo get the last step if needed:\n    \t// Get the terminal step\n    lastStep = steps[steps.length-1];\n    // Get the query string\n    query = this.stepsToQuery(steps);\n    // Find the containing element\n    startContainerParent = doc.querySelector(query);\n    // Find the text node within that element\n    if(startContainerParent && lastStep.type == \"text\") {\n    \tcontainer = startContainerParent.childNodes[lastStep.index];\n    }\n    */\n  }, {\n    key: \"stepsToQuerySelector\",\n    value: function stepsToQuerySelector(steps) {\n      var query = [\"html\"];\n      steps.forEach(function (step) {\n        var position = step.index + 1;\n        if (step.id) {\n          query.push(\"#\" + step.id);\n        } else if (step.type === \"text\") {\n          // unsupported in querySelector\n          // query.push(\"text()[\" + position + \"]\");\n        } else {\n          query.push(\"*:nth-child(\" + position + \")\");\n        }\n      });\n      return query.join(\">\");\n    }\n  }, {\n    key: \"textNodes\",\n    value: function textNodes(container, ignoreClass) {\n      return Array.prototype.slice.call(container.childNodes).filter(function (node) {\n        if (node.nodeType === TEXT_NODE) {\n          return true;\n        } else if (ignoreClass && node.classList.contains(ignoreClass)) {\n          return true;\n        }\n        return false;\n      });\n    }\n  }, {\n    key: \"walkToNode\",\n    value: function walkToNode(steps, _doc, ignoreClass) {\n      var doc = _doc || document;\n      var container = doc.documentElement;\n      var children;\n      var step;\n      var len = steps.length;\n      var i;\n      for (i = 0; i < len; i++) {\n        step = steps[i];\n        if (step.type === \"element\") {\n          //better to get a container using id as some times step.index may not be correct\n          //For ex.https://github.com/futurepress/epub.js/issues/561\n          if (step.id) {\n            container = doc.getElementById(step.id);\n          } else {\n            children = container.children || findChildren(container);\n            container = children[step.index];\n          }\n        } else if (step.type === \"text\") {\n          container = this.textNodes(container, ignoreClass)[step.index];\n        }\n        if (!container) {\n          //Break the for loop as due to incorrect index we can get error if\n          //container is undefined so that other functionailties works fine\n          //like navigation\n          break;\n        }\n      }\n      return container;\n    }\n  }, {\n    key: \"findNode\",\n    value: function findNode(steps, _doc, ignoreClass) {\n      var doc = _doc || document;\n      var container;\n      var xpath;\n      if (!ignoreClass && typeof doc.evaluate != \"undefined\") {\n        xpath = this.stepsToXpath(steps);\n        container = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n      } else if (ignoreClass) {\n        container = this.walkToNode(steps, doc, ignoreClass);\n      } else {\n        container = this.walkToNode(steps, doc);\n      }\n      return container;\n    }\n  }, {\n    key: \"fixMiss\",\n    value: function fixMiss(steps, offset, _doc, ignoreClass) {\n      var container = this.findNode(steps.slice(0, -1), _doc, ignoreClass);\n      var children = container.childNodes;\n      var map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n      var child;\n      var len;\n      var lastStepIndex = steps[steps.length - 1].index;\n      for (var childIndex in map) {\n        if (!map.hasOwnProperty(childIndex)) return;\n        if (map[childIndex] === lastStepIndex) {\n          child = children[childIndex];\n          len = child.textContent.length;\n          if (offset > len) {\n            offset = offset - len;\n          } else {\n            if (child.nodeType === ELEMENT_NODE) {\n              container = child.childNodes[0];\n            } else {\n              container = child;\n            }\n            break;\n          }\n        }\n      }\n      return {\n        container: container,\n        offset: offset\n      };\n    }\n\n    /**\n     * Creates a DOM range representing a CFI\n     * @param {document} _doc document referenced in the base\n     * @param {string} [ignoreClass]\n     * @return {Range}\n     */\n  }, {\n    key: \"toRange\",\n    value: function toRange(_doc, ignoreClass) {\n      var doc = _doc || document;\n      var range;\n      var start, end, startContainer, endContainer;\n      var cfi = this;\n      var startSteps, endSteps;\n      var needsIgnoring = ignoreClass ? doc.querySelector(\".\" + ignoreClass) != null : false;\n      var missed;\n      if (typeof doc.createRange !== \"undefined\") {\n        range = doc.createRange();\n      } else {\n        range = new RangeObject();\n      }\n      if (cfi.range) {\n        start = cfi.start;\n        startSteps = cfi.path.steps.concat(start.steps);\n        startContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);\n        end = cfi.end;\n        endSteps = cfi.path.steps.concat(end.steps);\n        endContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);\n      } else {\n        start = cfi.path;\n        startSteps = cfi.path.steps;\n        startContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);\n      }\n      if (startContainer) {\n        try {\n          if (start.terminal.offset != null) {\n            range.setStart(startContainer, start.terminal.offset);\n          } else {\n            range.setStart(startContainer, 0);\n          }\n        } catch (e) {\n          missed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n          range.setStart(missed.container, missed.offset);\n        }\n      } else {\n        console.log(\"No startContainer found for\", this.toString());\n        // No start found\n        return null;\n      }\n      if (endContainer) {\n        try {\n          if (end.terminal.offset != null) {\n            range.setEnd(endContainer, end.terminal.offset);\n          } else {\n            range.setEnd(endContainer, 0);\n          }\n        } catch (e) {\n          missed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n          range.setEnd(missed.container, missed.offset);\n        }\n      }\n\n      // doc.defaultView.getSelection().addRange(range);\n      return range;\n    }\n\n    /**\n     * Check if a string is wrapped with \"epubcfi()\"\n     * @param {string} str\n     * @returns {boolean}\n     */\n  }, {\n    key: \"isCfiString\",\n    value: function isCfiString(str) {\n      if (typeof str === \"string\" && str.indexOf(\"epubcfi(\") === 0 && str[str.length - 1] === \")\") {\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"generateChapterComponent\",\n    value: function generateChapterComponent(_spineNodeIndex, _pos, id) {\n      var pos = parseInt(_pos),\n        spineNodeIndex = (_spineNodeIndex + 1) * 2,\n        cfi = \"/\" + spineNodeIndex + \"/\";\n      cfi += (pos + 1) * 2;\n      if (id) {\n        cfi += \"[\" + id + \"]\";\n      }\n      return cfi;\n    }\n\n    /**\n     * Collapse a CFI Range to a single CFI Position\n     * @param {boolean} [toStart=false]\n     */\n  }, {\n    key: \"collapse\",\n    value: function collapse(toStart) {\n      if (!this.range) {\n        return;\n      }\n      this.range = false;\n      if (toStart) {\n        this.path.steps = this.path.steps.concat(this.start.steps);\n        this.path.terminal = this.start.terminal;\n      } else {\n        this.path.steps = this.path.steps.concat(this.end.steps);\n        this.path.terminal = this.end.terminal;\n      }\n    }\n  }]);\n  return EpubCFI;\n}();\nexport default EpubCFI;","map":{"version":3,"names":["extend","type","findChildren","RangeObject","isNumber","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","DOCUMENT_NODE","EpubCFI","cfiFrom","base","ignoreClass","_classCallCheck","str","spinePos","range","path","start","end","parseComponent","steps","checkType","parse","fromRange","fromNode","TypeError","_createClass","key","value","cfi","isCfiString","startContainer","nodeType","cfiStr","baseComponent","pathComponent","indexOf","length","slice","getChapterComponent","getPathComponent","getRange","index","componentStr","component","terminal","offset","assertion","parts","split","parseTerminal","shift","map","step","parseStep","bind","stepStr","num","has_brackets","id","match","parseInt","isNaN","termialStr","characterOffset","textLocationAssertion","indirection","ranges","getCharecterOffsetComponent","splitStr","joinSteps","part","segment","join","segmentString","toString","cfiString","compare","cfiOne","cfiTwo","stepsA","stepsB","terminalA","terminalB","rangeAStartSteps","rangeAEndSteps","rangeBEndSteps","rangeAStartTerminal","rangeAEndTerminal","rangeBStartTerminal","rangeBEndTerminal","concat","i","node","tagName","position","filteredStep","filteredNode","filter","filteredPosition","pathTo","currentNode","parentNode","unshift","push","equalStep","stepA","stepB","endContainer","startOffset","endOffset","needsIgnoring","ownerDocument","querySelector","collapsed","patchOffset","len","anchor","sibling","parent","previousSibling","nextSibling","isText","classList","contains","Error","curr","totalOffset","textContent","normalizedMap","children","output","prevIndex","currNodeType","prevNodeType","Array","prototype","call","textNodes","childNodes","stepsToXpath","xpath","forEach","stepsToQuerySelector","query","container","walkToNode","_doc","doc","document","documentElement","getElementById","findNode","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","fixMiss","child","lastStepIndex","childIndex","hasOwnProperty","toRange","startSteps","endSteps","missed","createRange","setStart","e","console","log","setEnd","generateChapterComponent","_spineNodeIndex","_pos","pos","spineNodeIndex","collapse","toStart"],"sources":["C:/Users/barbu/Desktop/projeto-Akin/node_modules/epubjs/src/epubcfi.js"],"sourcesContent":["import {extend, type, findChildren, RangeObject, isNumber} from \"./utils/core\";\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nconst DOCUMENT_NODE = 9;\n\n/**\n\t* Parsing and creation of EpubCFIs: http://www.idpf.org/epub/linking/cfi/epub-cfi.html\n\n\t* Implements:\n\t* - Character Offset: epubcfi(/6/4[chap01ref]!/4[body01]/10[para05]/2/1:3)\n\t* - Simple Ranges : epubcfi(/6/4[chap01ref]!/4[body01]/10[para05],/2/1:1,/3:4)\n\n\t* Does Not Implement:\n\t* - Temporal Offset (~)\n\t* - Spatial Offset (@)\n\t* - Temporal-Spatial Offset (~ + @)\n\t* - Text Location Assertion ([)\n\t* @class\n\t@param {string | Range | Node } [cfiFrom]\n\t@param {string | object} [base]\n\t@param {string} [ignoreClass] class to ignore when parsing DOM\n*/\nclass EpubCFI {\n\tconstructor(cfiFrom, base, ignoreClass){\n\t\tvar type;\n\n\t\tthis.str = \"\";\n\n\t\tthis.base = {};\n\t\tthis.spinePos = 0; // For compatibility\n\n\t\tthis.range = false; // true || false;\n\n\t\tthis.path = {};\n\t\tthis.start = null;\n\t\tthis.end = null;\n\n\t\t// Allow instantiation without the \"new\" keyword\n\t\tif (!(this instanceof EpubCFI)) {\n\t\t\treturn new EpubCFI(cfiFrom, base, ignoreClass);\n\t\t}\n\n\t\tif(typeof base === \"string\") {\n\t\t\tthis.base = this.parseComponent(base);\n\t\t} else if(typeof base === \"object\" && base.steps) {\n\t\t\tthis.base = base;\n\t\t}\n\n\t\ttype = this.checkType(cfiFrom);\n\n\n\t\tif(type === \"string\") {\n\t\t\tthis.str = cfiFrom;\n\t\t\treturn extend(this, this.parse(cfiFrom));\n\t\t} else if (type === \"range\") {\n\t\t\treturn extend(this, this.fromRange(cfiFrom, this.base, ignoreClass));\n\t\t} else if (type === \"node\") {\n\t\t\treturn extend(this, this.fromNode(cfiFrom, this.base, ignoreClass));\n\t\t} else if (type === \"EpubCFI\" && cfiFrom.path) {\n\t\t\treturn cfiFrom;\n\t\t} else if (!cfiFrom) {\n\t\t\treturn this;\n\t\t} else {\n\t\t\tthrow new TypeError(\"not a valid argument for EpubCFI\");\n\t\t}\n\n\t}\n\n\t/**\n\t * Check the type of constructor input\n\t * @private\n\t */\n\tcheckType(cfi) {\n\n\t\tif (this.isCfiString(cfi)) {\n\t\t\treturn \"string\";\n\t\t// Is a range object\n\t\t} else if (cfi && typeof cfi === \"object\" && (type(cfi) === \"Range\" || typeof(cfi.startContainer) != \"undefined\")){\n\t\t\treturn \"range\";\n\t\t} else if (cfi && typeof cfi === \"object\" && typeof(cfi.nodeType) != \"undefined\" ){ // || typeof cfi === \"function\"\n\t\t\treturn \"node\";\n\t\t} else if (cfi && typeof cfi === \"object\" && cfi instanceof EpubCFI){\n\t\t\treturn \"EpubCFI\";\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a cfi string to a CFI object representation\n\t * @param {string} cfiStr\n\t * @returns {object} cfi\n\t */\n\tparse(cfiStr) {\n\t\tvar cfi = {\n\t\t\tspinePos: -1,\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\t\tvar baseComponent, pathComponent, range;\n\n\t\tif(typeof cfiStr !== \"string\") {\n\t\t\treturn {spinePos: -1};\n\t\t}\n\n\t\tif(cfiStr.indexOf(\"epubcfi(\") === 0 && cfiStr[cfiStr.length-1] === \")\") {\n\t\t\t// Remove initial epubcfi( and ending )\n\t\t\tcfiStr = cfiStr.slice(8, cfiStr.length-1);\n\t\t}\n\n\t\tbaseComponent = this.getChapterComponent(cfiStr);\n\n\t\t// Make sure this is a valid cfi or return\n\t\tif(!baseComponent) {\n\t\t\treturn {spinePos: -1};\n\t\t}\n\n\t\tcfi.base = this.parseComponent(baseComponent);\n\n\t\tpathComponent = this.getPathComponent(cfiStr);\n\t\tcfi.path = this.parseComponent(pathComponent);\n\n\t\trange = this.getRange(cfiStr);\n\n\t\tif(range) {\n\t\t\tcfi.range = true;\n\t\t\tcfi.start = this.parseComponent(range[0]);\n\t\t\tcfi.end = this.parseComponent(range[1]);\n\t\t}\n\n\t\t// Get spine node position\n\t\t// cfi.spineSegment = cfi.base.steps[1];\n\n\t\t// Chapter segment is always the second step\n\t\tcfi.spinePos = cfi.base.steps[1].index;\n\n\t\treturn cfi;\n\t}\n\n\tparseComponent(componentStr){\n\t\tvar component = {\n\t\t\tsteps: [],\n\t\t\tterminal: {\n\t\t\t\toffset: null,\n\t\t\t\tassertion: null\n\t\t\t}\n\t\t};\n\t\tvar parts = componentStr.split(\":\");\n\t\tvar steps = parts[0].split(\"/\");\n\t\tvar terminal;\n\n\t\tif(parts.length > 1) {\n\t\t\tterminal = parts[1];\n\t\t\tcomponent.terminal = this.parseTerminal(terminal);\n\t\t}\n\n\t\tif (steps[0] === \"\") {\n\t\t\tsteps.shift(); // Ignore the first slash\n\t\t}\n\n\t\tcomponent.steps = steps.map(function(step){\n\t\t\treturn this.parseStep(step);\n\t\t}.bind(this));\n\n\t\treturn component;\n\t}\n\n\tparseStep(stepStr){\n\t\tvar type, num, index, has_brackets, id;\n\n\t\thas_brackets = stepStr.match(/\\[(.*)\\]/);\n\t\tif(has_brackets && has_brackets[1]){\n\t\t\tid = has_brackets[1];\n\t\t}\n\n\t\t//-- Check if step is a text node or element\n\t\tnum = parseInt(stepStr);\n\n\t\tif(isNaN(num)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(num % 2 === 0) { // Even = is an element\n\t\t\ttype = \"element\";\n\t\t\tindex = num / 2 - 1;\n\t\t} else {\n\t\t\ttype = \"text\";\n\t\t\tindex = (num - 1 ) / 2;\n\t\t}\n\n\t\treturn {\n\t\t\t\"type\" : type,\n\t\t\t\"index\" : index,\n\t\t\t\"id\" : id || null\n\t\t};\n\t}\n\n\tparseTerminal(termialStr){\n\t\tvar characterOffset, textLocationAssertion;\n\t\tvar assertion = termialStr.match(/\\[(.*)\\]/);\n\n\t\tif(assertion && assertion[1]){\n\t\t\tcharacterOffset = parseInt(termialStr.split(\"[\")[0]);\n\t\t\ttextLocationAssertion = assertion[1];\n\t\t} else {\n\t\t\tcharacterOffset = parseInt(termialStr);\n\t\t}\n\n\t\tif (!isNumber(characterOffset)) {\n\t\t\tcharacterOffset = null;\n\t\t}\n\n\t\treturn {\n\t\t\t\"offset\": characterOffset,\n\t\t\t\"assertion\": textLocationAssertion\n\t\t};\n\n\t}\n\n\tgetChapterComponent(cfiStr) {\n\n\t\tvar indirection = cfiStr.split(\"!\");\n\n\t\treturn indirection[0];\n\t}\n\n\tgetPathComponent(cfiStr) {\n\n\t\tvar indirection = cfiStr.split(\"!\");\n\n\t\tif(indirection[1]) {\n\t\t\tlet ranges = indirection[1].split(\",\");\n\t\t\treturn ranges[0];\n\t\t}\n\n\t}\n\n\tgetRange(cfiStr) {\n\n\t\tvar ranges = cfiStr.split(\",\");\n\n\t\tif(ranges.length === 3){\n\t\t\treturn [\n\t\t\t\tranges[1],\n\t\t\t\tranges[2]\n\t\t\t];\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetCharecterOffsetComponent(cfiStr) {\n\t\tvar splitStr = cfiStr.split(\":\");\n\t\treturn splitStr[1] || \"\";\n\t}\n\n\tjoinSteps(steps) {\n\t\tif(!steps) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\treturn steps.map(function(part){\n\t\t\tvar segment = \"\";\n\n\t\t\tif(part.type === \"element\") {\n\t\t\t\tsegment += (part.index + 1) * 2;\n\t\t\t}\n\n\t\t\tif(part.type === \"text\") {\n\t\t\t\tsegment += 1 + (2 * part.index); // TODO: double check that this is odd\n\t\t\t}\n\n\t\t\tif(part.id) {\n\t\t\t\tsegment += \"[\" + part.id + \"]\";\n\t\t\t}\n\n\t\t\treturn segment;\n\n\t\t}).join(\"/\");\n\n\t}\n\n\tsegmentString(segment) {\n\t\tvar segmentString = \"/\";\n\n\t\tsegmentString += this.joinSteps(segment.steps);\n\n\t\tif(segment.terminal && segment.terminal.offset != null){\n\t\t\tsegmentString += \":\" + segment.terminal.offset;\n\t\t}\n\n\t\tif(segment.terminal && segment.terminal.assertion != null){\n\t\t\tsegmentString += \"[\" + segment.terminal.assertion + \"]\";\n\t\t}\n\n\t\treturn segmentString;\n\t}\n\n\t/**\n\t * Convert CFI to a epubcfi(...) string\n\t * @returns {string} epubcfi\n\t */\n\ttoString() {\n\t\tvar cfiString = \"epubcfi(\";\n\n\t\tcfiString += this.segmentString(this.base);\n\n\t\tcfiString += \"!\";\n\t\tcfiString += this.segmentString(this.path);\n\n\t\t// Add Range, if present\n\t\tif(this.range && this.start) {\n\t\t\tcfiString += \",\";\n\t\t\tcfiString += this.segmentString(this.start);\n\t\t}\n\n\t\tif(this.range && this.end) {\n\t\t\tcfiString += \",\";\n\t\t\tcfiString += this.segmentString(this.end);\n\t\t}\n\n\t\tcfiString += \")\";\n\n\t\treturn cfiString;\n\t}\n\n\n\t/**\n\t * Compare which of two CFIs is earlier in the text\n\t * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0\n\t */\n\tcompare(cfiOne, cfiTwo) {\n\t\tvar stepsA, stepsB;\n\t\tvar terminalA, terminalB;\n\n\t\tvar rangeAStartSteps, rangeAEndSteps;\n\t\tvar rangeBEndSteps, rangeBEndSteps;\n\t\tvar rangeAStartTerminal, rangeAEndTerminal;\n\t\tvar rangeBStartTerminal, rangeBEndTerminal;\n\n\t\tif(typeof cfiOne === \"string\") {\n\t\t\tcfiOne = new EpubCFI(cfiOne);\n\t\t}\n\t\tif(typeof cfiTwo === \"string\") {\n\t\t\tcfiTwo = new EpubCFI(cfiTwo);\n\t\t}\n\t\t// Compare Spine Positions\n\t\tif(cfiOne.spinePos > cfiTwo.spinePos) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(cfiOne.spinePos < cfiTwo.spinePos) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (cfiOne.range) {\n\t\t\tstepsA = cfiOne.path.steps.concat(cfiOne.start.steps);\n\t\t\tterminalA = cfiOne.start.terminal;\n\t\t} else {\n\t\t\tstepsA = cfiOne.path.steps;\n\t\t\tterminalA = cfiOne.path.terminal;\n\t\t}\n\n\t\tif (cfiTwo.range) {\n\t\t\tstepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);\n\t\t\tterminalB = cfiTwo.start.terminal;\n\t\t} else {\n\t\t\tstepsB = cfiTwo.path.steps;\n\t\t\tterminalB = cfiTwo.path.terminal;\n\t\t}\n\n\t\t// Compare Each Step in the First item\n\t\tfor (var i = 0; i < stepsA.length; i++) {\n\t\t\tif(!stepsA[i]) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(!stepsB[i]) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(stepsA[i].index > stepsB[i].index) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif(stepsA[i].index < stepsB[i].index) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// Otherwise continue checking\n\t\t}\n\n\t\t// All steps in First equal to Second and First is Less Specific\n\t\tif(stepsA.length < stepsB.length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// Compare the character offset of the text node\n\t\tif(terminalA.offset > terminalB.offset) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(terminalA.offset < terminalB.offset) {\n\t\t\treturn -1;\n\t\t}\n\n\t\t// CFI's are equal\n\t\treturn 0;\n\t}\n\n\tstep(node) {\n\t\tvar nodeType = (node.nodeType === TEXT_NODE) ? \"text\" : \"element\";\n\n\t\treturn {\n\t\t\t\"id\" : node.id,\n\t\t\t\"tagName\" : node.tagName,\n\t\t\t\"type\" : nodeType,\n\t\t\t\"index\" : this.position(node)\n\t\t};\n\t}\n\n\tfilteredStep(node, ignoreClass) {\n\t\tvar filteredNode = this.filter(node, ignoreClass);\n\t\tvar nodeType;\n\n\t\t// Node filtered, so ignore\n\t\tif (!filteredNode) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise add the filter node in\n\t\tnodeType = (filteredNode.nodeType === TEXT_NODE) ? \"text\" : \"element\";\n\n\t\treturn {\n\t\t\t\"id\" : filteredNode.id,\n\t\t\t\"tagName\" : filteredNode.tagName,\n\t\t\t\"type\" : nodeType,\n\t\t\t\"index\" : this.filteredPosition(filteredNode, ignoreClass)\n\t\t};\n\t}\n\n\tpathTo(node, offset, ignoreClass) {\n\t\tvar segment = {\n\t\t\tsteps: [],\n\t\t\tterminal: {\n\t\t\t\toffset: null,\n\t\t\t\tassertion: null\n\t\t\t}\n\t\t};\n\t\tvar currentNode = node;\n\t\tvar step;\n\n\t\twhile(currentNode && currentNode.parentNode &&\n\t\t\t\t\tcurrentNode.parentNode.nodeType != DOCUMENT_NODE) {\n\n\t\t\tif (ignoreClass) {\n\t\t\t\tstep = this.filteredStep(currentNode, ignoreClass);\n\t\t\t} else {\n\t\t\t\tstep = this.step(currentNode);\n\t\t\t}\n\n\t\t\tif (step) {\n\t\t\t\tsegment.steps.unshift(step);\n\t\t\t}\n\n\t\t\tcurrentNode = currentNode.parentNode;\n\n\t\t}\n\n\t\tif (offset != null && offset >= 0) {\n\n\t\t\tsegment.terminal.offset = offset;\n\n\t\t\t// Make sure we are getting to a textNode if there is an offset\n\t\t\tif(segment.steps[segment.steps.length-1].type != \"text\") {\n\t\t\t\tsegment.steps.push({\n\t\t\t\t\t\"type\" : \"text\",\n\t\t\t\t\t\"index\" : 0\n\t\t\t\t});\n\t\t\t}\n\n\t\t}\n\n\n\t\treturn segment;\n\t}\n\n\tequalStep(stepA, stepB) {\n\t\tif (!stepA || !stepB) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif(stepA.index === stepB.index &&\n\t\t\t stepA.id === stepB.id &&\n\t\t\t stepA.type === stepB.type) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Create a CFI object from a Range\n\t * @param {Range} range\n\t * @param {string | object} base\n\t * @param {string} [ignoreClass]\n\t * @returns {object} cfi\n\t */\n\tfromRange(range, base, ignoreClass) {\n\t\tvar cfi = {\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\n\t\tvar start = range.startContainer;\n\t\tvar end = range.endContainer;\n\n\t\tvar startOffset = range.startOffset;\n\t\tvar endOffset = range.endOffset;\n\n\t\tvar needsIgnoring = false;\n\n\t\tif (ignoreClass) {\n\t\t\t// Tell pathTo if / what to ignore\n\t\t\tneedsIgnoring = (start.ownerDocument.querySelector(\".\" + ignoreClass) != null);\n\t\t}\n\n\n\t\tif (typeof base === \"string\") {\n\t\t\tcfi.base = this.parseComponent(base);\n\t\t\tcfi.spinePos = cfi.base.steps[1].index;\n\t\t} else if (typeof base === \"object\") {\n\t\t\tcfi.base = base;\n\t\t}\n\n\t\tif (range.collapsed) {\n\t\t\tif (needsIgnoring) {\n\t\t\t\tstartOffset = this.patchOffset(start, startOffset, ignoreClass);\n\t\t\t}\n\t\t\tcfi.path = this.pathTo(start, startOffset, ignoreClass);\n\t\t} else {\n\t\t\tcfi.range = true;\n\n\t\t\tif (needsIgnoring) {\n\t\t\t\tstartOffset = this.patchOffset(start, startOffset, ignoreClass);\n\t\t\t}\n\n\t\t\tcfi.start = this.pathTo(start, startOffset, ignoreClass);\n\t\t\tif (needsIgnoring) {\n\t\t\t\tendOffset = this.patchOffset(end, endOffset, ignoreClass);\n\t\t\t}\n\n\t\t\tcfi.end = this.pathTo(end, endOffset, ignoreClass);\n\n\t\t\t// Create a new empty path\n\t\t\tcfi.path = {\n\t\t\t\tsteps: [],\n\t\t\t\tterminal: null\n\t\t\t};\n\n\t\t\t// Push steps that are shared between start and end to the common path\n\t\t\tvar len = cfi.start.steps.length;\n\t\t\tvar i;\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tif (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {\n\t\t\t\t\tif(i === len-1) {\n\t\t\t\t\t\t// Last step is equal, check terminals\n\t\t\t\t\t\tif(cfi.start.terminal === cfi.end.terminal) {\n\t\t\t\t\t\t\t// CFI's are equal\n\t\t\t\t\t\t\tcfi.path.steps.push(cfi.start.steps[i]);\n\t\t\t\t\t\t\t// Not a range\n\t\t\t\t\t\t\tcfi.range = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcfi.path.steps.push(cfi.start.steps[i]);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);\n\t\t\tcfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);\n\n\t\t\t// TODO: Add Sanity check to make sure that the end if greater than the start\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Create a CFI object from a Node\n\t * @param {Node} anchor\n\t * @param {string | object} base\n\t * @param {string} [ignoreClass]\n\t * @returns {object} cfi\n\t */\n\tfromNode(anchor, base, ignoreClass) {\n\t\tvar cfi = {\n\t\t\trange: false,\n\t\t\tbase: {},\n\t\t\tpath: {},\n\t\t\tstart: null,\n\t\t\tend: null\n\t\t};\n\n\t\tif (typeof base === \"string\") {\n\t\t\tcfi.base = this.parseComponent(base);\n\t\t\tcfi.spinePos = cfi.base.steps[1].index;\n\t\t} else if (typeof base === \"object\") {\n\t\t\tcfi.base = base;\n\t\t}\n\n\t\tcfi.path = this.pathTo(anchor, null, ignoreClass);\n\n\t\treturn cfi;\n\t}\n\n\tfilter(anchor, ignoreClass) {\n\t\tvar needsIgnoring;\n\t\tvar sibling; // to join with\n\t\tvar parent, previousSibling, nextSibling;\n\t\tvar isText = false;\n\n\t\tif (anchor.nodeType === TEXT_NODE) {\n\t\t\tisText = true;\n\t\t\tparent = anchor.parentNode;\n\t\t\tneedsIgnoring = anchor.parentNode.classList.contains(ignoreClass);\n\t\t} else {\n\t\t\tisText = false;\n\t\t\tneedsIgnoring = anchor.classList.contains(ignoreClass);\n\t\t}\n\n\t\tif (needsIgnoring && isText) {\n\t\t\tpreviousSibling = parent.previousSibling;\n\t\t\tnextSibling = parent.nextSibling;\n\n\t\t\t// If the sibling is a text node, join the nodes\n\t\t\tif (previousSibling && previousSibling.nodeType === TEXT_NODE) {\n\t\t\t\tsibling = previousSibling;\n\t\t\t} else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {\n\t\t\t\tsibling = nextSibling;\n\t\t\t}\n\n\t\t\tif (sibling) {\n\t\t\t\treturn sibling;\n\t\t\t} else {\n\t\t\t\t// Parent will be ignored on next step\n\t\t\t\treturn anchor;\n\t\t\t}\n\n\t\t} else if (needsIgnoring && !isText) {\n\t\t\t// Otherwise just skip the element node\n\t\t\treturn false;\n\t\t} else {\n\t\t\t// No need to filter\n\t\t\treturn anchor;\n\t\t}\n\n\t}\n\n\tpatchOffset(anchor, offset, ignoreClass) {\n\t\tif (anchor.nodeType != TEXT_NODE) {\n\t\t\tthrow new Error(\"Anchor must be a text node\");\n\t\t}\n\n\t\tvar curr = anchor;\n\t\tvar totalOffset = offset;\n\n\t\t// If the parent is a ignored node, get offset from it's start\n\t\tif (anchor.parentNode.classList.contains(ignoreClass)) {\n\t\t\tcurr = anchor.parentNode;\n\t\t}\n\n\t\twhile (curr.previousSibling) {\n\t\t\tif(curr.previousSibling.nodeType === ELEMENT_NODE) {\n\t\t\t\t// Originally a text node, so join\n\t\t\t\tif(curr.previousSibling.classList.contains(ignoreClass)){\n\t\t\t\t\ttotalOffset += curr.previousSibling.textContent.length;\n\t\t\t\t} else {\n\t\t\t\t\tbreak; // Normal node, dont join\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If the previous sibling is a text node, join the nodes\n\t\t\t\ttotalOffset += curr.previousSibling.textContent.length;\n\t\t\t}\n\n\t\t\tcurr = curr.previousSibling;\n\t\t}\n\n\t\treturn totalOffset;\n\n\t}\n\n\tnormalizedMap(children, nodeType, ignoreClass) {\n\t\tvar output = {};\n\t\tvar prevIndex = -1;\n\t\tvar i, len = children.length;\n\t\tvar currNodeType;\n\t\tvar prevNodeType;\n\n\t\tfor (i = 0; i < len; i++) {\n\n\t\t\tcurrNodeType = children[i].nodeType;\n\n\t\t\t// Check if needs ignoring\n\t\t\tif (currNodeType === ELEMENT_NODE &&\n\t\t\t\t\tchildren[i].classList.contains(ignoreClass)) {\n\t\t\t\tcurrNodeType = TEXT_NODE;\n\t\t\t}\n\n\t\t\tif (i > 0 &&\n\t\t\t\t\tcurrNodeType === TEXT_NODE &&\n\t\t\t\t\tprevNodeType === TEXT_NODE) {\n\t\t\t\t// join text nodes\n\t\t\t\toutput[i] = prevIndex;\n\t\t\t} else if (nodeType === currNodeType){\n\t\t\t\tprevIndex = prevIndex + 1;\n\t\t\t\toutput[i] = prevIndex;\n\t\t\t}\n\n\t\t\tprevNodeType = currNodeType;\n\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tposition(anchor) {\n\t\tvar children, index;\n\t\tif (anchor.nodeType === ELEMENT_NODE) {\n\t\t\tchildren = anchor.parentNode.children;\n\t\t\tif (!children) {\n\t\t\t\tchildren = findChildren(anchor.parentNode);\n\t\t\t}\n\t\t\tindex = Array.prototype.indexOf.call(children, anchor);\n\t\t} else {\n\t\t\tchildren = this.textNodes(anchor.parentNode);\n\t\t\tindex = children.indexOf(anchor);\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tfilteredPosition(anchor, ignoreClass) {\n\t\tvar children, index, map;\n\n\t\tif (anchor.nodeType === ELEMENT_NODE) {\n\t\t\tchildren = anchor.parentNode.children;\n\t\t\tmap = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);\n\t\t} else {\n\t\t\tchildren = anchor.parentNode.childNodes;\n\t\t\t// Inside an ignored node\n\t\t\tif(anchor.parentNode.classList.contains(ignoreClass)) {\n\t\t\t\tanchor = anchor.parentNode;\n\t\t\t\tchildren = anchor.parentNode.childNodes;\n\t\t\t}\n\t\t\tmap = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n\t\t}\n\n\n\t\tindex = Array.prototype.indexOf.call(children, anchor);\n\n\t\treturn map[index];\n\t}\n\n\tstepsToXpath(steps) {\n\t\tvar xpath = [\".\", \"*\"];\n\n\t\tsteps.forEach(function(step){\n\t\t\tvar position = step.index + 1;\n\n\t\t\tif(step.id){\n\t\t\t\txpath.push(\"*[position()=\" + position + \" and @id='\" + step.id + \"']\");\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\txpath.push(\"text()[\" + position + \"]\");\n\t\t\t} else {\n\t\t\t\txpath.push(\"*[\" + position + \"]\");\n\t\t\t}\n\t\t});\n\n\t\treturn xpath.join(\"/\");\n\t}\n\n\n\t/*\n\n\tTo get the last step if needed:\n\n\t// Get the terminal step\n\tlastStep = steps[steps.length-1];\n\t// Get the query string\n\tquery = this.stepsToQuery(steps);\n\t// Find the containing element\n\tstartContainerParent = doc.querySelector(query);\n\t// Find the text node within that element\n\tif(startContainerParent && lastStep.type == \"text\") {\n\t\tcontainer = startContainerParent.childNodes[lastStep.index];\n\t}\n\t*/\n\tstepsToQuerySelector(steps) {\n\t\tvar query = [\"html\"];\n\n\t\tsteps.forEach(function(step){\n\t\t\tvar position = step.index + 1;\n\n\t\t\tif(step.id){\n\t\t\t\tquery.push(\"#\" + step.id);\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\t// unsupported in querySelector\n\t\t\t\t// query.push(\"text()[\" + position + \"]\");\n\t\t\t} else {\n\t\t\t\tquery.push(\"*:nth-child(\" + position + \")\");\n\t\t\t}\n\t\t});\n\n\t\treturn query.join(\">\");\n\n\t}\n\n\ttextNodes(container, ignoreClass) {\n\t\treturn Array.prototype.slice.call(container.childNodes).\n\t\t\tfilter(function (node) {\n\t\t\t\tif (node.nodeType === TEXT_NODE) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (ignoreClass && node.classList.contains(ignoreClass)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t}\n\n\twalkToNode(steps, _doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar container = doc.documentElement;\n\t\tvar children;\n\t\tvar step;\n\t\tvar len = steps.length;\n\t\tvar i;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tstep = steps[i];\n\n\t\t\tif(step.type === \"element\") {\n\t\t\t\t//better to get a container using id as some times step.index may not be correct\n\t\t\t\t//For ex.https://github.com/futurepress/epub.js/issues/561\n\t\t\t\tif(step.id) {\n\t\t\t\t\tcontainer = doc.getElementById(step.id);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchildren = container.children || findChildren(container);\n\t\t\t\t\tcontainer = children[step.index];\n\t\t\t\t}\n\t\t\t} else if(step.type === \"text\") {\n\t\t\t\tcontainer = this.textNodes(container, ignoreClass)[step.index];\n\t\t\t}\n\t\t\tif(!container) {\n\t\t\t\t//Break the for loop as due to incorrect index we can get error if\n\t\t\t\t//container is undefined so that other functionailties works fine\n\t\t\t\t//like navigation\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tfindNode(steps, _doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar container;\n\t\tvar xpath;\n\n\t\tif(!ignoreClass && typeof doc.evaluate != \"undefined\") {\n\t\t\txpath = this.stepsToXpath(steps);\n\t\t\tcontainer = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n\t\t} else if(ignoreClass) {\n\t\t\tcontainer = this.walkToNode(steps, doc, ignoreClass);\n\t\t} else {\n\t\t\tcontainer = this.walkToNode(steps, doc);\n\t\t}\n\n\t\treturn container;\n\t}\n\n\tfixMiss(steps, offset, _doc, ignoreClass) {\n\t\tvar container = this.findNode(steps.slice(0,-1), _doc, ignoreClass);\n\t\tvar children = container.childNodes;\n\t\tvar map = this.normalizedMap(children, TEXT_NODE, ignoreClass);\n\t\tvar child;\n\t\tvar len;\n\t\tvar lastStepIndex = steps[steps.length-1].index;\n\n\t\tfor (let childIndex in map) {\n\t\t\tif (!map.hasOwnProperty(childIndex)) return;\n\n\t\t\tif(map[childIndex] === lastStepIndex) {\n\t\t\t\tchild = children[childIndex];\n\t\t\t\tlen = child.textContent.length;\n\t\t\t\tif(offset > len) {\n\t\t\t\t\toffset = offset - len;\n\t\t\t\t} else {\n\t\t\t\t\tif (child.nodeType === ELEMENT_NODE) {\n\t\t\t\t\t\tcontainer = child.childNodes[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainer = child;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcontainer: container,\n\t\t\toffset: offset\n\t\t};\n\n\t}\n\n\t/**\n\t * Creates a DOM range representing a CFI\n\t * @param {document} _doc document referenced in the base\n\t * @param {string} [ignoreClass]\n\t * @return {Range}\n\t */\n\ttoRange(_doc, ignoreClass) {\n\t\tvar doc = _doc || document;\n\t\tvar range;\n\t\tvar start, end, startContainer, endContainer;\n\t\tvar cfi = this;\n\t\tvar startSteps, endSteps;\n\t\tvar needsIgnoring = ignoreClass ? (doc.querySelector(\".\" + ignoreClass) != null) : false;\n\t\tvar missed;\n\n\t\tif (typeof(doc.createRange) !== \"undefined\") {\n\t\t\trange = doc.createRange();\n\t\t} else {\n\t\t\trange = new RangeObject();\n\t\t}\n\n\t\tif (cfi.range) {\n\t\t\tstart = cfi.start;\n\t\t\tstartSteps = cfi.path.steps.concat(start.steps);\n\t\t\tstartContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);\n\t\t\tend = cfi.end;\n\t\t\tendSteps = cfi.path.steps.concat(end.steps);\n\t\t\tendContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);\n\t\t} else {\n\t\t\tstart = cfi.path;\n\t\t\tstartSteps = cfi.path.steps;\n\t\t\tstartContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);\n\t\t}\n\n\t\tif(startContainer) {\n\t\t\ttry {\n\n\t\t\t\tif(start.terminal.offset != null) {\n\t\t\t\t\trange.setStart(startContainer, start.terminal.offset);\n\t\t\t\t} else {\n\t\t\t\t\trange.setStart(startContainer, 0);\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\t\t\t\tmissed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n\t\t\t\trange.setStart(missed.container, missed.offset);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log(\"No startContainer found for\", this.toString());\n\t\t\t// No start found\n\t\t\treturn null;\n\t\t}\n\n\t\tif (endContainer) {\n\t\t\ttry {\n\n\t\t\t\tif(end.terminal.offset != null) {\n\t\t\t\t\trange.setEnd(endContainer, end.terminal.offset);\n\t\t\t\t} else {\n\t\t\t\t\trange.setEnd(endContainer, 0);\n\t\t\t\t}\n\n\t\t\t} catch (e) {\n\t\t\t\tmissed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);\n\t\t\t\trange.setEnd(missed.container, missed.offset);\n\t\t\t}\n\t\t}\n\n\n\t\t// doc.defaultView.getSelection().addRange(range);\n\t\treturn range;\n\t}\n\n\t/**\n\t * Check if a string is wrapped with \"epubcfi()\"\n\t * @param {string} str\n\t * @returns {boolean}\n\t */\n\tisCfiString(str) {\n\t\tif(typeof str === \"string\" &&\n\t\t\tstr.indexOf(\"epubcfi(\") === 0 &&\n\t\t\tstr[str.length-1] === \")\") {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgenerateChapterComponent(_spineNodeIndex, _pos, id) {\n\t\tvar pos = parseInt(_pos),\n\t\t\t\tspineNodeIndex = (_spineNodeIndex + 1) * 2,\n\t\t\t\tcfi = \"/\"+spineNodeIndex+\"/\";\n\n\t\tcfi += (pos + 1) * 2;\n\n\t\tif(id) {\n\t\t\tcfi += \"[\" + id + \"]\";\n\t\t}\n\n\t\treturn cfi;\n\t}\n\n\t/**\n\t * Collapse a CFI Range to a single CFI Position\n\t * @param {boolean} [toStart=false]\n\t */\n\tcollapse(toStart) {\n\t\tif (!this.range) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.range = false;\n\n\t\tif (toStart) {\n\t\t\tthis.path.steps = this.path.steps.concat(this.start.steps);\n\t\t\tthis.path.terminal = this.start.terminal;\n\t\t} else {\n\t\t\tthis.path.steps = this.path.steps.concat(this.end.steps);\n\t\t\tthis.path.terminal = this.end.terminal;\n\t\t}\n\n\t}\n}\n\nexport default EpubCFI;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}