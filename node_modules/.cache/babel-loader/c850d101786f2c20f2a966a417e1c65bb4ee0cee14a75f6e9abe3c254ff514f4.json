{"ast":null,"code":"import _classCallCheck from \"C:/Users/barbu/Desktop/projeto-Akin/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/barbu/Desktop/projeto-Akin/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { defer, requestAnimationFrame } from \"./core\";\n\n/**\n * Queue for handling tasks one at a time\n * @class\n * @param {scope} context what this will resolve to in the tasks\n */\nvar Queue = /*#__PURE__*/function () {\n  function Queue(context) {\n    _classCallCheck(this, Queue);\n    this._q = [];\n    this.context = context;\n    this.tick = requestAnimationFrame;\n    this.running = false;\n    this.paused = false;\n  }\n\n  /**\n   * Add an item to the queue\n   * @return {Promise}\n   */\n  _createClass(Queue, [{\n    key: \"enqueue\",\n    value: function enqueue() {\n      var deferred, promise;\n      var queued;\n      var task = [].shift.call(arguments);\n      var args = arguments;\n\n      // Handle single args without context\n      // if(args && !Array.isArray(args)) {\n      //   args = [args];\n      // }\n      if (!task) {\n        throw new Error(\"No Task Provided\");\n      }\n      if (typeof task === \"function\") {\n        deferred = new defer();\n        promise = deferred.promise;\n        queued = {\n          \"task\": task,\n          \"args\": args,\n          //\"context\"  : context,\n          \"deferred\": deferred,\n          \"promise\": promise\n        };\n      } else {\n        // Task is a promise\n        queued = {\n          \"promise\": task\n        };\n      }\n      this._q.push(queued);\n\n      // Wait to start queue flush\n      if (this.paused == false && !this.running) {\n        // setTimeout(this.flush.bind(this), 0);\n        // this.tick.call(window, this.run.bind(this));\n        this.run();\n      }\n      return queued.promise;\n    }\n\n    /**\n     * Run one item\n     * @return {Promise}\n     */\n  }, {\n    key: \"dequeue\",\n    value: function dequeue() {\n      var inwait, task, result;\n      if (this._q.length && !this.paused) {\n        inwait = this._q.shift();\n        task = inwait.task;\n        if (task) {\n          // console.log(task)\n\n          result = task.apply(this.context, inwait.args);\n          if (result && typeof result[\"then\"] === \"function\") {\n            // Task is a function that returns a promise\n            return result.then(function () {\n              inwait.deferred.resolve.apply(this.context, arguments);\n            }.bind(this), function () {\n              inwait.deferred.reject.apply(this.context, arguments);\n            }.bind(this));\n          } else {\n            // Task resolves immediately\n            inwait.deferred.resolve.apply(this.context, result);\n            return inwait.promise;\n          }\n        } else if (inwait.promise) {\n          // Task is a promise\n          return inwait.promise;\n        }\n      } else {\n        inwait = new defer();\n        inwait.deferred.resolve();\n        return inwait.promise;\n      }\n    }\n\n    // Run All Immediately\n  }, {\n    key: \"dump\",\n    value: function dump() {\n      while (this._q.length) {\n        this.dequeue();\n      }\n    }\n\n    /**\n     * Run all tasks sequentially, at convince\n     * @return {Promise}\n     */\n  }, {\n    key: \"run\",\n    value: function run() {\n      var _this = this;\n      if (!this.running) {\n        this.running = true;\n        this.defered = new defer();\n      }\n      this.tick.call(window, function () {\n        if (_this._q.length) {\n          _this.dequeue().then(function () {\n            this.run();\n          }.bind(_this));\n        } else {\n          _this.defered.resolve();\n          _this.running = undefined;\n        }\n      });\n\n      // Unpause\n      if (this.paused == true) {\n        this.paused = false;\n      }\n      return this.defered.promise;\n    }\n\n    /**\n     * Flush all, as quickly as possible\n     * @return {Promise}\n     */\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this.running) {\n        return this.running;\n      }\n      if (this._q.length) {\n        this.running = this.dequeue().then(function () {\n          this.running = undefined;\n          return this.flush();\n        }.bind(this));\n        return this.running;\n      }\n    }\n\n    /**\n     * Clear all items in wait\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._q = [];\n    }\n\n    /**\n     * Get the number of tasks in the queue\n     * @return {number} tasks\n     */\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this._q.length;\n    }\n\n    /**\n     * Pause a running queue\n     */\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this.paused = true;\n    }\n\n    /**\n     * End the queue\n     */\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._q = [];\n      this.running = false;\n      this.paused = true;\n    }\n  }]);\n  return Queue;\n}();\n/**\n * Create a new task from a callback\n * @class\n * @private\n * @param {function} task\n * @param {array} args\n * @param {scope} context\n * @return {function} task\n */\nvar Task = /*#__PURE__*/_createClass(function Task(task, args, context) {\n  _classCallCheck(this, Task);\n  return function () {\n    var _this2 = this;\n    var toApply = arguments || [];\n    return new Promise(function (resolve, reject) {\n      var callback = function callback(value, err) {\n        if (!value && err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      };\n      // Add the callback to the arguments list\n      toApply.push(callback);\n\n      // Apply all arguments to the functions\n      task.apply(context || _this2, toApply);\n    });\n  };\n});\nexport default Queue;\nexport { Task };","map":{"version":3,"names":["defer","requestAnimationFrame","Queue","context","_classCallCheck","_q","tick","running","paused","_createClass","key","value","enqueue","deferred","promise","queued","task","shift","call","arguments","args","Error","push","run","dequeue","inwait","result","length","apply","then","resolve","bind","reject","dump","_this","defered","window","undefined","flush","clear","pause","stop","Task","_this2","toApply","Promise","callback","err"],"sources":["C:/Users/barbu/Desktop/projeto-Akin/node_modules/epubjs/src/utils/queue.js"],"sourcesContent":["import {defer, requestAnimationFrame} from \"./core\";\n\n/**\n * Queue for handling tasks one at a time\n * @class\n * @param {scope} context what this will resolve to in the tasks\n */\nclass Queue {\n\tconstructor(context){\n\t\tthis._q = [];\n\t\tthis.context = context;\n\t\tthis.tick = requestAnimationFrame;\n\t\tthis.running = false;\n\t\tthis.paused = false;\n\t}\n\n\t/**\n\t * Add an item to the queue\n\t * @return {Promise}\n\t */\n\tenqueue() {\n\t\tvar deferred, promise;\n\t\tvar queued;\n\t\tvar task = [].shift.call(arguments);\n\t\tvar args = arguments;\n\n\t\t// Handle single args without context\n\t\t// if(args && !Array.isArray(args)) {\n\t\t//   args = [args];\n\t\t// }\n\t\tif(!task) {\n\t\t\tthrow new Error(\"No Task Provided\");\n\t\t}\n\n\t\tif(typeof task === \"function\"){\n\n\t\t\tdeferred = new defer();\n\t\t\tpromise = deferred.promise;\n\n\t\t\tqueued = {\n\t\t\t\t\"task\" : task,\n\t\t\t\t\"args\"     : args,\n\t\t\t\t//\"context\"  : context,\n\t\t\t\t\"deferred\" : deferred,\n\t\t\t\t\"promise\" : promise\n\t\t\t};\n\n\t\t} else {\n\t\t\t// Task is a promise\n\t\t\tqueued = {\n\t\t\t\t\"promise\" : task\n\t\t\t};\n\n\t\t}\n\n\t\tthis._q.push(queued);\n\n\t\t// Wait to start queue flush\n\t\tif (this.paused == false && !this.running) {\n\t\t\t// setTimeout(this.flush.bind(this), 0);\n\t\t\t// this.tick.call(window, this.run.bind(this));\n\t\t\tthis.run();\n\t\t}\n\n\t\treturn queued.promise;\n\t}\n\n\t/**\n\t * Run one item\n\t * @return {Promise}\n\t */\n\tdequeue(){\n\t\tvar inwait, task, result;\n\n\t\tif(this._q.length && !this.paused) {\n\t\t\tinwait = this._q.shift();\n\t\t\ttask = inwait.task;\n\t\t\tif(task){\n\t\t\t\t// console.log(task)\n\n\t\t\t\tresult = task.apply(this.context, inwait.args);\n\n\t\t\t\tif(result && typeof result[\"then\"] === \"function\") {\n\t\t\t\t\t// Task is a function that returns a promise\n\t\t\t\t\treturn result.then(function(){\n\t\t\t\t\t\tinwait.deferred.resolve.apply(this.context, arguments);\n\t\t\t\t\t}.bind(this), function() {\n\t\t\t\t\t\tinwait.deferred.reject.apply(this.context, arguments);\n\t\t\t\t\t}.bind(this));\n\t\t\t\t} else {\n\t\t\t\t\t// Task resolves immediately\n\t\t\t\t\tinwait.deferred.resolve.apply(this.context, result);\n\t\t\t\t\treturn inwait.promise;\n\t\t\t\t}\n\n\n\n\t\t\t} else if(inwait.promise) {\n\t\t\t\t// Task is a promise\n\t\t\t\treturn inwait.promise;\n\t\t\t}\n\n\t\t} else {\n\t\t\tinwait = new defer();\n\t\t\tinwait.deferred.resolve();\n\t\t\treturn inwait.promise;\n\t\t}\n\n\t}\n\n\t// Run All Immediately\n\tdump(){\n\t\twhile(this._q.length) {\n\t\t\tthis.dequeue();\n\t\t}\n\t}\n\n\t/**\n\t * Run all tasks sequentially, at convince\n\t * @return {Promise}\n\t */\n\trun(){\n\n\t\tif(!this.running){\n\t\t\tthis.running = true;\n\t\t\tthis.defered = new defer();\n\t\t}\n\n\t\tthis.tick.call(window, () => {\n\n\t\t\tif(this._q.length) {\n\n\t\t\t\tthis.dequeue()\n\t\t\t\t\t.then(function(){\n\t\t\t\t\t\tthis.run();\n\t\t\t\t\t}.bind(this));\n\n\t\t\t} else {\n\t\t\t\tthis.defered.resolve();\n\t\t\t\tthis.running = undefined;\n\t\t\t}\n\n\t\t});\n\n\t\t// Unpause\n\t\tif(this.paused == true) {\n\t\t\tthis.paused = false;\n\t\t}\n\n\t\treturn this.defered.promise;\n\t}\n\n\t/**\n\t * Flush all, as quickly as possible\n\t * @return {Promise}\n\t */\n\tflush(){\n\n\t\tif(this.running){\n\t\t\treturn this.running;\n\t\t}\n\n\t\tif(this._q.length) {\n\t\t\tthis.running = this.dequeue()\n\t\t\t\t.then(function(){\n\t\t\t\t\tthis.running = undefined;\n\t\t\t\t\treturn this.flush();\n\t\t\t\t}.bind(this));\n\n\t\t\treturn this.running;\n\t\t}\n\n\t}\n\n\t/**\n\t * Clear all items in wait\n\t */\n\tclear(){\n\t\tthis._q = [];\n\t}\n\n\t/**\n\t * Get the number of tasks in the queue\n\t * @return {number} tasks\n\t */\n\tlength(){\n\t\treturn this._q.length;\n\t}\n\n\t/**\n\t * Pause a running queue\n\t */\n\tpause(){\n\t\tthis.paused = true;\n\t}\n\n\t/**\n\t * End the queue\n\t */\n\tstop(){\n\t\tthis._q = [];\n\t\tthis.running = false;\n\t\tthis.paused = true;\n\t}\n}\n\n\n/**\n * Create a new task from a callback\n * @class\n * @private\n * @param {function} task\n * @param {array} args\n * @param {scope} context\n * @return {function} task\n */\nclass Task {\n\tconstructor(task, args, context){\n\n\t\treturn function(){\n\t\t\tvar toApply = arguments || [];\n\n\t\t\treturn new Promise( (resolve, reject) => {\n\t\t\t\tvar callback = function(value, err){\n\t\t\t\t\tif (!value && err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t// Add the callback to the arguments list\n\t\t\t\ttoApply.push(callback);\n\n\t\t\t\t// Apply all arguments to the functions\n\t\t\t\ttask.apply(context || this, toApply);\n\n\t\t\t});\n\n\t\t};\n\n\t}\n}\n\n\nexport default Queue;\nexport { Task };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}